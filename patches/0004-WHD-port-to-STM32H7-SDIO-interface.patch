From f37ac819fe9fe9d2e16ae5c135954e964eb7eb44 Mon Sep 17 00:00:00 2001
From: Martino Facchin <m.facchin@arduino.cc>
Date: Wed, 28 Oct 2020 15:14:48 +0100
Subject: [PATCH 04/67] WHD: port to STM32H7 SDIO interface

---
 .../interface/cy_network_buffer.c             | 114 +++
 .../interface/cy_network_buffer.h             | 185 ++++
 .../COMPONENT_WHD/interface/cy_result.h       | 135 +++
 .../COMPONENT_WHD/interface/cyabs_rtos.h      | 672 ++++++++++++++
 .../COMPONENT_WHD/interface/cyabs_rtos_impl.h |  77 ++
 .../interface/cyabs_rtos_rtxv5.c              | 828 ++++++++++++++++++
 .../COMPONENT_WHD/interface/cyhal_gpio.cpp    |  83 ++
 .../COMPONENT_WHD/interface/cyhal_gpio.h      | 208 +++++
 .../COMPONENT_WHD/interface/cyhal_hw_types.h  | 103 +++
 .../COMPONENT_WHD/interface/cyhal_modules.h   |  86 ++
 .../COMPONENT_WHD/interface/cyhal_sdio.c      | 800 +++++++++++++++++
 .../COMPONENT_WHD/interface/cyhal_sdio.h      | 274 ++++++
 .../COMPONENT_WHD/interface/cyhal_spi.h       | 250 ++++++
 .../COMPONENT_WHD/port/cy_hal.c               |  76 ++
 .../COMPONENT_WHD/port/cy_syslib.h            | 592 +++++++++++++
 .../COMPONENT_WHD/port/cy_utils.h             |  79 ++
 .../COMPONENT_WHD/port/cybsp_wifi.c           | 219 +++++
 .../COMPONENT_WHD/port/cybsp_wifi.h           | 109 +++
 .../COMPONENT_WHD/whd_config.h                |  66 ++
 19 files changed, 4956 insertions(+)
 create mode 100644 targets/TARGET_STM/TARGET_STM32H7/TARGET_STM32H747xI/TARGET_PORTENTA_H7/COMPONENT_WHD/interface/cy_network_buffer.c
 create mode 100644 targets/TARGET_STM/TARGET_STM32H7/TARGET_STM32H747xI/TARGET_PORTENTA_H7/COMPONENT_WHD/interface/cy_network_buffer.h
 create mode 100644 targets/TARGET_STM/TARGET_STM32H7/TARGET_STM32H747xI/TARGET_PORTENTA_H7/COMPONENT_WHD/interface/cy_result.h
 create mode 100644 targets/TARGET_STM/TARGET_STM32H7/TARGET_STM32H747xI/TARGET_PORTENTA_H7/COMPONENT_WHD/interface/cyabs_rtos.h
 create mode 100644 targets/TARGET_STM/TARGET_STM32H7/TARGET_STM32H747xI/TARGET_PORTENTA_H7/COMPONENT_WHD/interface/cyabs_rtos_impl.h
 create mode 100644 targets/TARGET_STM/TARGET_STM32H7/TARGET_STM32H747xI/TARGET_PORTENTA_H7/COMPONENT_WHD/interface/cyabs_rtos_rtxv5.c
 create mode 100644 targets/TARGET_STM/TARGET_STM32H7/TARGET_STM32H747xI/TARGET_PORTENTA_H7/COMPONENT_WHD/interface/cyhal_gpio.cpp
 create mode 100644 targets/TARGET_STM/TARGET_STM32H7/TARGET_STM32H747xI/TARGET_PORTENTA_H7/COMPONENT_WHD/interface/cyhal_gpio.h
 create mode 100644 targets/TARGET_STM/TARGET_STM32H7/TARGET_STM32H747xI/TARGET_PORTENTA_H7/COMPONENT_WHD/interface/cyhal_hw_types.h
 create mode 100644 targets/TARGET_STM/TARGET_STM32H7/TARGET_STM32H747xI/TARGET_PORTENTA_H7/COMPONENT_WHD/interface/cyhal_modules.h
 create mode 100644 targets/TARGET_STM/TARGET_STM32H7/TARGET_STM32H747xI/TARGET_PORTENTA_H7/COMPONENT_WHD/interface/cyhal_sdio.c
 create mode 100644 targets/TARGET_STM/TARGET_STM32H7/TARGET_STM32H747xI/TARGET_PORTENTA_H7/COMPONENT_WHD/interface/cyhal_sdio.h
 create mode 100644 targets/TARGET_STM/TARGET_STM32H7/TARGET_STM32H747xI/TARGET_PORTENTA_H7/COMPONENT_WHD/interface/cyhal_spi.h
 create mode 100644 targets/TARGET_STM/TARGET_STM32H7/TARGET_STM32H747xI/TARGET_PORTENTA_H7/COMPONENT_WHD/port/cy_hal.c
 create mode 100644 targets/TARGET_STM/TARGET_STM32H7/TARGET_STM32H747xI/TARGET_PORTENTA_H7/COMPONENT_WHD/port/cy_syslib.h
 create mode 100644 targets/TARGET_STM/TARGET_STM32H7/TARGET_STM32H747xI/TARGET_PORTENTA_H7/COMPONENT_WHD/port/cy_utils.h
 create mode 100644 targets/TARGET_STM/TARGET_STM32H7/TARGET_STM32H747xI/TARGET_PORTENTA_H7/COMPONENT_WHD/port/cybsp_wifi.c
 create mode 100644 targets/TARGET_STM/TARGET_STM32H7/TARGET_STM32H747xI/TARGET_PORTENTA_H7/COMPONENT_WHD/port/cybsp_wifi.h
 create mode 100644 targets/TARGET_STM/TARGET_STM32H7/TARGET_STM32H747xI/TARGET_PORTENTA_H7/COMPONENT_WHD/whd_config.h

diff --git a/targets/TARGET_STM/TARGET_STM32H7/TARGET_STM32H747xI/TARGET_PORTENTA_H7/COMPONENT_WHD/interface/cy_network_buffer.c b/targets/TARGET_STM/TARGET_STM32H7/TARGET_STM32H747xI/TARGET_PORTENTA_H7/COMPONENT_WHD/interface/cy_network_buffer.c
new file mode 100644
index 0000000000..1446fae34c
--- /dev/null
+++ b/targets/TARGET_STM/TARGET_STM32H7/TARGET_STM32H747xI/TARGET_PORTENTA_H7/COMPONENT_WHD/interface/cy_network_buffer.c
@@ -0,0 +1,114 @@
+/***************************************************************************//**
+* \file cy_network_buffer.c
+*
+* \brief
+* Basic set of APIs for dealing with network packet buffers. This is used by WHD
+* for relaying data between the network stack and the connectivity chip.
+*
+********************************************************************************
+* \copyright
+* Copyright 2018-2019 Cypress Semiconductor Corporation
+* SPDX-License-Identifier: Apache-2.0
+*
+* Licensed under the Apache License, Version 2.0 (the "License");
+* you may not use this file except in compliance with the License.
+* You may obtain a copy of the License at
+*
+*     http://www.apache.org/licenses/LICENSE-2.0
+*
+* Unless required by applicable law or agreed to in writing, software
+* distributed under the License is distributed on an "AS IS" BASIS,
+* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+* See the License for the specific language governing permissions and
+* limitations under the License.
+*******************************************************************************/
+
+#if 1
+
+#include <stdlib.h>
+#include "cy_network_buffer.h"
+#include "cy_utils.h"
+#include "lwip/memp.h"
+#include "whd_bus_protocol_interface.h"
+
+#define  SDIO_BLOCK_SIZE (64U)
+
+whd_result_t cy_host_buffer_get(whd_buffer_t *buffer, whd_buffer_dir_t direction, unsigned short size, unsigned long timeout_ms)
+{
+    UNUSED_PARAMETER( direction );
+    UNUSED_PARAMETER( timeout_ms );
+    struct pbuf *p = NULL;
+    if ( ( direction == WHD_NETWORK_TX) && ( size <= PBUF_POOL_BUFSIZE ) )
+    {
+    	p = pbuf_alloc(PBUF_RAW, size, PBUF_POOL);
+    }
+    else
+    {
+    	p = pbuf_alloc(PBUF_RAW, size+SDIO_BLOCK_SIZE, PBUF_RAM);
+    	if ( p != NULL )
+    	{
+    	    p->len = size;
+    	    p->tot_len -=  SDIO_BLOCK_SIZE;
+    	}
+    }
+    if (p != NULL )
+    {
+        *buffer = p;
+    	return WHD_SUCCESS;
+    }
+    else
+    {
+        return WHD_BUFFER_ALLOC_FAIL;
+    }
+}
+
+void cy_buffer_release(whd_buffer_t buffer, whd_buffer_dir_t direction)
+{
+    UNUSED_PARAMETER( direction );
+    (void) pbuf_free( (struct pbuf *)buffer );
+}
+
+uint8_t *cy_buffer_get_current_piece_data_pointer(whd_buffer_t buffer)
+{
+    CY_ASSERT(buffer != NULL);
+    struct pbuf *pbuffer= (struct pbuf*) buffer;
+    return (uint8_t*) pbuffer->payload;
+}
+
+uint16_t cy_buffer_get_current_piece_size(whd_buffer_t buffer)
+{
+    CY_ASSERT(buffer != NULL);
+    struct pbuf *pbuffer = (struct pbuf*) buffer;
+    return (uint16_t) pbuffer->len;
+}
+
+whd_result_t cy_buffer_set_size(whd_buffer_t buffer, unsigned short size)
+{
+    CY_ASSERT(buffer != NULL);
+    struct pbuf * pbuffer = (struct pbuf *) buffer;
+
+    if ( size > (unsigned short) WHD_LINK_MTU  + LWIP_MEM_ALIGN_SIZE(LWIP_MEM_ALIGN_SIZE(sizeof(struct pbuf))) + LWIP_MEM_ALIGN_SIZE(size) )
+    {
+        return WHD_PMK_WRONG_LENGTH;
+    }
+
+    pbuffer->tot_len = size;
+    pbuffer->len = size;
+
+    return CY_RSLT_SUCCESS;
+}
+
+whd_result_t cy_buffer_add_remove_at_front(whd_buffer_t *buffer, int32_t add_remove_amount)
+{
+    CY_ASSERT(buffer != NULL);
+    struct pbuf **pbuffer = (struct pbuf**) buffer;
+
+    if ( (u8_t) 0 != pbuf_header( *pbuffer, ( s16_t )( -add_remove_amount ) ) )
+    {
+        return WHD_PMK_WRONG_LENGTH;
+    }
+
+    return WHD_SUCCESS;
+}
+
+#endif /* defined(CYBSP_WIFI_CAPABLE) */
diff --git a/targets/TARGET_STM/TARGET_STM32H7/TARGET_STM32H747xI/TARGET_PORTENTA_H7/COMPONENT_WHD/interface/cy_network_buffer.h b/targets/TARGET_STM/TARGET_STM32H7/TARGET_STM32H747xI/TARGET_PORTENTA_H7/COMPONENT_WHD/interface/cy_network_buffer.h
new file mode 100644
index 0000000000..44f3872498
--- /dev/null
+++ b/targets/TARGET_STM/TARGET_STM32H7/TARGET_STM32H747xI/TARGET_PORTENTA_H7/COMPONENT_WHD/interface/cy_network_buffer.h
@@ -0,0 +1,185 @@
+/***************************************************************************//**
+* \file cy_network_buffer.h
+*
+* \brief
+* Basic set of APIs for dealing with network packet buffers. This is used by WHD
+* for relaying data between the network stack and the connectivity chip.
+*
+********************************************************************************
+* \copyright
+* Copyright 2018-2019 Cypress Semiconductor Corporation
+* SPDX-License-Identifier: Apache-2.0
+*
+* Licensed under the Apache License, Version 2.0 (the "License");
+* you may not use this file except in compliance with the License.
+* You may obtain a copy of the License at
+*
+*     http://www.apache.org/licenses/LICENSE-2.0
+*
+* Unless required by applicable law or agreed to in writing, software
+* distributed under the License is distributed on an "AS IS" BASIS,
+* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+* See the License for the specific language governing permissions and
+* limitations under the License.
+*******************************************************************************/
+
+/**
+* \addtogroup group_bsp_network_buffer Buffer management
+* \{
+* Basic set of APIs for dealing with network packet buffers
+*
+* \defgroup group_bsp_network_buffer_functions Functions
+*/
+
+#ifndef __CY_NETWORK_BUFFER_H__
+#define __CY_NETWORK_BUFFER_H__
+
+#if 1
+
+#include <stdint.h>
+#include <stdbool.h>
+#include "cy_result.h"
+#include "whd.h"
+#include "whd_network_types.h"
+#include "lwip/pbuf.h"
+
+#if defined(__cplusplus)
+extern "C" {
+#endif
+
+
+/**
+* \addtogroup group_bsp_network_buffer_functions
+* \{
+*/
+
+/** Allocates a packet buffer
+ *
+ *  Attempts to allocate a packet buffer of the size requested. It can do this
+ *  by allocating a pre-existing packet from a pool, using a static buffer,
+ *  or by dynamically allocating memory. The method of allocation does not
+ *  concern WHD, however it must match the way the network stack expects packet
+ *  buffers to be allocated. Usually WHD requires packet of size of WHD_LINK_MTU
+ *  which includes the MTU. Refer to whd_types.h to find the size of WHD_LINK_MTU.
+ *
+ *  @param buffer    : A pointer which receives the allocated packet buffer handle
+ *  @param direction : Indicates transmit/receive direction that the packet buffer is
+ *                    used for. This may be needed if tx/rx pools are separate.
+ *  @param size      : The number of bytes to allocate.
+ *  @param timeout_ms: Time to wait for a packet buffer to be available
+ *
+ *  @return          : CY_RSLT_SUCCESS or WHD_BUFFER_ALLOC_FAIL if the buffer could not be allocated
+ */
+whd_result_t cy_host_buffer_get(whd_buffer_t *buffer, whd_buffer_dir_t direction, unsigned short size, unsigned long timeout_ms);
+
+/** Releases a packet buffer
+ *
+ *  This function is used by WHD to indicate that it no longer requires
+ *  a packet buffer. The buffer can then be released back into a pool for
+ *  reuse, or the dynamically allocated memory can be freed, according to
+ *  how the packet was allocated.
+ *  Returns void since WHD cannot do anything about failures
+ *
+ *  @param buffer    : The handle of the packet buffer to be released
+ *  @param direction : Indicates transmit/receive direction that the packet buffer has
+ *                     been used for. This might be needed if tx/rx pools are separate.
+ */
+void cy_buffer_release(whd_buffer_t buffer, whd_buffer_dir_t direction);
+
+/** Retrieves the current pointer of a packet buffer
+ *
+ *  Since packet buffers usually need to be created with space at the
+ *  front for additional headers, this function allows WHD to get
+ *  the current 'front' location pointer.
+ *
+ *  @param buffer : The handle of the packet buffer whose pointer is to be retrieved
+ *
+ *  @return       : The packet buffer's current pointer.
+ */
+uint8_t *cy_buffer_get_current_piece_data_pointer(whd_buffer_t buffer);
+
+/** Retrieves the size of a packet buffer
+ *
+ *  Since packet buffers usually need to be created with space at the
+ *  front for additional headers, the memory block used to contain a packet buffer
+ *  will often be larger than the current size of the packet buffer data.
+ *  This function allows WHD to retrieve the current size of a packet buffer's data.
+ *
+ *  @param buffer : The handle of the packet buffer whose size is to be retrieved
+ *
+ *  @return       :  The size of the packet buffer.
+ */
+uint16_t cy_buffer_get_current_piece_size(whd_buffer_t buffer);
+
+/** Sets the current size of a WHD packet
+ *
+ *  This function sets the current length of a WHD packet buffer
+ *
+ *  @param buffer : The packet to be modified
+ *  @param size   : The new size of the packet buffer
+ *
+ *  @return       : CY_RSLT_SUCCESS or WHD_PMK_WRONG_LENGTH if the requested size is not valid
+ */
+whd_result_t cy_buffer_set_size(whd_buffer_t buffer, unsigned short size);
+
+/** Moves the current pointer of a packet buffer
+ *
+ *  Since packet buffers usually need to be created with space at the front for additional headers,
+ *  this function allows WHD to move the current 'front' location pointer so that it has space to
+ *  add headers to transmit packets, and so that the network stack does not see the internal WHD
+ *  headers on received packets.
+ *
+ *  @param buffer            : A pointer to the handle of the current packet buffer for which the
+ *                             current pointer will be moved. On return this may contain a pointer
+ *                             to a newly allocated packet buffer which has been daisy chained to
+ *                             the front of the given one. This would be the case if the given packet
+ *                             buffer  didn't have enough space at the front.
+ *  @param add_remove_amount : This is the number of bytes to move the current pointer of the packet
+ *                             buffer - a negative value increases the space for headers at the front
+ *                             of the packet, a positive value decreases the space.
+ *
+ *  @return                  : CY_RSLT_SUCCESS or WHD_PMK_WRONG_LENGTH if the added amount is outside 
+ *                             the size of the buffer
+ */
+whd_result_t cy_buffer_add_remove_at_front(whd_buffer_t *buffer, int32_t add_remove_amount);
+
+
+/** Called by WHD to pass received data to the network stack
+ *
+ *  Packets received from the Wi-Fi network by WHD are forwarded to by calling function ptr which
+ *  must be implemented in the network interface. Ethernet headers
+ *  are present at the start of these packet buffers.
+ *
+ *  This function is called asynchronously in the context of the
+ *  WHD thread whenever new data has arrived.
+ *  Packet buffers are allocated within WHD, and ownership is transferred
+ *  to the network stack. The network stack or application is thus
+ *  responsible for releasing the packet buffers.
+ *  Most packet buffering systems have a pointer to the 'current point' within
+ *  the packet buffer. When this function is called, the pointer points
+ *  to the start of the Ethernet header. There is other inconsequential data
+ *  before the Ethernet header.
+ *
+ *  It is preferable that the (whd_network_process_ethernet_data)() function simply puts
+ *  the received packet on a queue for processing by another thread. This avoids the
+ *  WHD thread being unnecessarily tied up which would delay other packets
+ *  being transmitted or received.
+ *
+ *  @param interface : The interface on which the packet was received.
+ *  @param buffer    : Handle of the packet which has just been received. Responsibility for
+ *                    releasing this buffer is transferred from WHD at this point.
+ *
+ */
+void cy_network_process_ethernet_data(whd_interface_t interface, whd_buffer_t buffer);
+
+/** \} group_bsp_network_buffer_functions */
+
+#ifdef __cplusplus
+}
+#endif /* __cplusplus */
+
+#endif /* defined(CYBSP_WIFI_CAPABLE) */
+
+/** \} group_bsp_network_buffer */
+
+#endif // __CY_NETWORK_BUFFER_H__
diff --git a/targets/TARGET_STM/TARGET_STM32H7/TARGET_STM32H747xI/TARGET_PORTENTA_H7/COMPONENT_WHD/interface/cy_result.h b/targets/TARGET_STM/TARGET_STM32H7/TARGET_STM32H747xI/TARGET_PORTENTA_H7/COMPONENT_WHD/interface/cy_result.h
new file mode 100644
index 0000000000..40b21b0f43
--- /dev/null
+++ b/targets/TARGET_STM/TARGET_STM32H7/TARGET_STM32H747xI/TARGET_PORTENTA_H7/COMPONENT_WHD/interface/cy_result.h
@@ -0,0 +1,135 @@
+/***************************************************************************//**
+* \file cy_result.h
+*
+* \brief
+* Basic function result handling. Defines a simple type for conveying
+* information about whether something succeeded or details about any issues
+* that were detected.
+*
+********************************************************************************
+* \copyright
+* Copyright 2018-2019 Cypress Semiconductor Corporation
+* SPDX-License-Identifier: Apache-2.0
+*
+* Licensed under the Apache License, Version 2.0 (the "License");
+* you may not use this file except in compliance with the License.
+* You may obtain a copy of the License at
+*
+*     http://www.apache.org/licenses/LICENSE-2.0
+*
+* Unless required by applicable law or agreed to in writing, software
+* distributed under the License is distributed on an "AS IS" BASIS,
+* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+* See the License for the specific language governing permissions and
+* limitations under the License.
+*******************************************************************************/
+
+/**
+ * \addtogroup group_result Result Type
+ * \ingroup group_abstraction
+ * \{
+ * Basic function result handling. Defines a simple type for conveying
+ * information about whether something succeeded or details about any issues
+ * that were detected.
+ *
+ * \defgroup group_result_macros Macros
+ */
+
+#pragma once
+
+#include <stdint.h>
+
+#if defined(__cplusplus)
+extern "C" {
+#endif
+
+/**
+ * \addtogroup group_result_macros
+ * \{
+ */
+
+/** Mask for the bit at position "x" */
+#define CY_BIT_MASK(x)                     ( (1U << (x) ) - 1U )
+
+/** Bit position of the result code */
+#define CY_RSLT_CODE_POSITION              (0U)
+/** Bit width of the result code */
+#define CY_RSLT_CODE_WIDTH                 (16U)
+/** Bit position of the result type */
+#define CY_RSLT_TYPE_POSITION              (16U)
+/** Bit width of the result type */
+#define CY_RSLT_TYPE_WIDTH                 (2U)
+/** Bit position of the module identifier */
+#define CY_RSLT_MODULE_POSITION            (18U)
+/** Bit width of the module identifier */
+#define CY_RSLT_MODULE_WIDTH               (14U)
+
+/** Mask for the result code */
+#define CY_RSLT_CODE_MASK                  CY_BIT_MASK(CY_RSLT_CODE_WIDTH)
+/** Mask for the module identifier */
+#define CY_RSLT_MODULE_MASK                CY_BIT_MASK(CY_RSLT_MODULE_WIDTH)
+/** Mask for the result type */
+#define CY_RSLT_TYPE_MASK                  CY_BIT_MASK(CY_RSLT_TYPE_WIDTH)
+
+/** Informational-only result status */
+#define CY_RSLT_TYPE_INFO                  (0U)
+/** Warning result */
+#define CY_RSLT_TYPE_WARNING               (1U)
+/** Error result */
+#define CY_RSLT_TYPE_ERROR                 (2U)
+/** Fatal error result */
+#define CY_RSLT_TYPE_FATAL                 (3U)
+
+/** Get the value of the result code field */
+#define CY_RSLT_GET_CODE(x)                ( ( (x) >> CY_RSLT_CODE_POSITION ) & CY_RSLT_CODE_MASK )
+/** Get the value of the result type field */
+#define CY_RSLT_GET_TYPE(x)                ( ( (x) >> CY_RSLT_TYPE_POSITION ) & CY_RSLT_TYPE_MASK )
+/** Get the value of the module identifier field */
+#define CY_RSLT_GET_MODULE(x)              ( ( (x) >> CY_RSLT_MODULE_POSITION ) & CY_RSLT_MODULE_MASK )
+
+
+/**** DRIVER Module codes: 0x0000 - 0x00FF ****/
+/** Base identifier for peripheral driver library */
+#define CY_RSLT_MODULE_DRIVERS_PDL_BASE           (0x0000U)
+/** Base identifier for peripheral driver library */
+#define CY_RSLT_MODULE_DRIVERS_WHD_BASE           (0x0080U)
+
+/**** ABSTRACTION Module codes: 0x0100 - 0x01FF ****/
+/** Base identifier for chip support modules */
+#define CY_RSLT_MODULE_ABSTRACTION_HAL_BASE       (0x0100U)
+/** Base identifier for board support modules */
+#define CY_RSLT_MODULE_ABSTRACTION_BSP            (0x0180U)
+/** Base identifier for file system modules */
+#define CY_RSLT_MODULE_ABSTRACTION_FS             (0x0181U)
+/** Base identifier for resource abstraction modules */
+#define CY_RSLT_MODULE_ABSTRACTION_RESOURCE       (0x0182U)
+/** Base identifier for rtos abstraction modules */
+#define CY_RSLT_MODULE_ABSTRACTION_OS             (0x0183U)
+/** Base identifier for environment abstraction modules */
+#define CY_RSLT_MODULE_ABSTRACTION_ENV            (0x0184U)
+
+/**** Middleware Module codes: 0x0200 - 0x02FF ****/
+#define CY_RSLT_MODULE_MIDDLEWARE_BASE            (0x0200U)
+
+
+
+/** Provides the result of an operation as a structured bitfield */
+typedef uint32_t cy_rslt_t;
+
+/** Result value indicating success */
+#define CY_RSLT_SUCCESS                    ( (cy_rslt_t)0x00000000U )
+
+/** Create a result value from the specified type, module, and result code */
+#define CY_RSLT_CREATE(type, module, code) \
+    ( ( ( (module) & CY_RSLT_MODULE_MASK ) << CY_RSLT_MODULE_POSITION ) | \
+      ( ( (code) & CY_RSLT_CODE_MASK ) << CY_RSLT_CODE_POSITION ) | \
+      ( ( (type) & CY_RSLT_TYPE_MASK ) << CY_RSLT_TYPE_POSITION ) )
+
+/** \} group_result_macros */
+
+#ifdef __cplusplus
+}
+#endif
+
+/** \} group_result */
+
diff --git a/targets/TARGET_STM/TARGET_STM32H7/TARGET_STM32H747xI/TARGET_PORTENTA_H7/COMPONENT_WHD/interface/cyabs_rtos.h b/targets/TARGET_STM/TARGET_STM32H7/TARGET_STM32H747xI/TARGET_PORTENTA_H7/COMPONENT_WHD/interface/cyabs_rtos.h
new file mode 100644
index 0000000000..b92a800dfd
--- /dev/null
+++ b/targets/TARGET_STM/TARGET_STM32H7/TARGET_STM32H747xI/TARGET_PORTENTA_H7/COMPONENT_WHD/interface/cyabs_rtos.h
@@ -0,0 +1,672 @@
+/***************************************************************************//**
+* \file cyabs_rtos.h
+*
+* \brief
+* Defines the Cypress RTOS Interface. Provides prototypes for functions that
+* allow Cypress libraries to use RTOS resources such as threads, mutexes &
+* timing functions in an abstract way. The APIs are implemented in the Port
+* Layer RTOS interface which is specific to the RTOS in use.
+*
+********************************************************************************
+* \copyright
+* Copyright 2018-2019 Cypress Semiconductor Corporation
+* SPDX-License-Identifier: Apache-2.0
+*
+* Licensed under the Apache License, Version 2.0 (the "License");
+* you may not use this file except in compliance with the License.
+* You may obtain a copy of the License at
+*
+*     http://www.apache.org/licenses/LICENSE-2.0
+*
+* Unless required by applicable law or agreed to in writing, software
+* distributed under the License is distributed on an "AS IS" BASIS,
+* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+* See the License for the specific language governing permissions and
+* limitations under the License.
+*******************************************************************************/
+
+#ifndef INCLUDED_CY_RTOS_INTERFACE_H_
+#define INCLUDED_CY_RTOS_INTERFACE_H_
+
+#include "cyabs_rtos_impl.h"
+#include "cy_result.h"
+#include <stdint.h>
+#include <stdbool.h>
+
+/**
+* \defgroup group_abstraction_rtos_common Common 
+* \defgroup group_abstraction_rtos_mutex Mutex
+* \defgroup group_abstraction_rtos_queue Queue
+* \defgroup group_abstraction_rtos_semaphore Semaphore
+* \defgroup group_abstraction_rtos_threads Threading
+* \defgroup group_abstraction_rtos_time Time
+* \defgroup group_abstraction_rtos_timer Timer
+*/
+
+#ifdef __cplusplus
+extern "C"
+{
+#endif
+
+/*********************************************** CONSTANTS **********************************************/
+
+/** 
+  * \ingroup group_abstraction_rtos_common  
+  * \{
+  */
+
+/** Used with RTOS calls that require a timeout.  This implies the call will never timeout. */
+#define CY_RTOS_NEVER_TIMEOUT ( (uint32_t)0xffffffffUL )
+
+//
+// Note on error strategy.  If the error is a normal part of operation (timeouts, full queues, empty
+// queues), the these errors are listed here and the abstraction layer implementation must map from the
+// underlying errors to these.  If the errors are special cases, the the error CY_RTOS_GENERAL_ERROR can be
+// returns and cy_rtos_last_error() used to retrieve the RTOS specific error message.
+//
+/** Requested operation did not complete in the specified time */
+#define CY_RTOS_TIMEOUT                     CY_RSLT_CREATE(CY_RSLT_TYPE_ERROR, CY_RSLT_MODULE_ABSTRACTION_OS, 0)
+/** The RTOS could not allocate memory for the specified operation */
+#define CY_RTOS_NO_MEMORY                   CY_RSLT_CREATE(CY_RSLT_TYPE_ERROR, CY_RSLT_MODULE_ABSTRACTION_OS, 1)
+/** An error occured in the RTOS */
+#define CY_RTOS_GENERAL_ERROR               CY_RSLT_CREATE(CY_RSLT_TYPE_ERROR, CY_RSLT_MODULE_ABSTRACTION_OS, 2)
+/** A bad argument was passed into the APIs */
+#define CY_RTOS_BAD_PARAM                   CY_RSLT_CREATE(CY_RSLT_TYPE_ERROR, CY_RSLT_MODULE_ABSTRACTION_OS, 5)
+/** A memory alignment issue was detected. Ensure memory provided is aligned per CY_RTOS_ALIGNMENT */
+#define CY_RTOS_ALIGNMENT_ERROR             CY_RSLT_CREATE(CY_RSLT_TYPE_ERROR, CY_RSLT_MODULE_ABSTRACTION_OS, 6)
+
+/** \} group_abstraction_rtos_common */
+
+/**
+  * \ingroup group_abstraction_rtos_queue
+  * \{
+  */
+
+/** The Queue is already full and can't accept any more items at this time */
+#define CY_RTOS_QUEUE_FULL                  CY_RSLT_CREATE(CY_RSLT_TYPE_ERROR, CY_RSLT_MODULE_ABSTRACTION_OS, 3)
+/** The Queue is empty and has nothing to remove */
+#define CY_RTOS_QUEUE_EMPTY                 CY_RSLT_CREATE(CY_RSLT_TYPE_ERROR, CY_RSLT_MODULE_ABSTRACTION_OS, 4)
+
+/** \} group_abstraction_rtos_queue */
+
+/*********************************************** TYPES **********************************************/
+
+/**
+ * The state a thread can be in
+ * 
+ * \ingroup group_abstraction_rtos_threads
+ */
+typedef enum cy_thread_state
+{
+    CY_THREAD_STATE_INACTIVE,   /**< thread has not started or was terminated but not yet joined */
+    CY_THREAD_STATE_READY,      /**< thread can run, but is not currently */
+    CY_THREAD_STATE_RUNNING,    /**< thread is currently running */
+    CY_THREAD_STATE_BLOCKED,    /**< thread is blocked waiting for something */
+    CY_THREAD_STATE_TERMINATED, /**< thread has terminated but not freed */
+    CY_THREAD_STATE_UNKNOWN,    /**< thread is in an unknown state */
+} cy_thread_state_t;
+
+/**
+ * The type of timer
+ * 
+ * \ingroup group_abstraction_rtos_timer
+ */
+typedef enum cy_timer_trigger_type
+{
+    CY_TIMER_TYPE_PERIODIC,                             /**< called periodically until stopped */
+    CY_TIMER_TYPE_ONCE,                                 /**< called once only */
+    cy_timer_type_periodic = CY_TIMER_TYPE_PERIODIC,    /**< \deprecated replaced by CY_TIMER_TYPE_PERIODIC */
+    cy_timer_type_once = CY_TIMER_TYPE_ONCE,            /**< \deprecated replaced by CY_TIMER_TYPE_ONCE */
+} cy_timer_trigger_type_t ;
+
+/**
+ * The type of a function that is the entry point for a thread
+ *
+ * @param[in] arg the argument passed from the thread create call to the entry function
+ * 
+ * \ingroup group_abstraction_rtos_threads
+ */
+typedef void (*cy_thread_entry_fn_t)(cy_thread_arg_t arg) ;
+
+/**
+ * The callback function to be called by a timer
+ * 
+ * \ingroup group_abstraction_rtos_timer
+ */
+typedef void (*cy_timer_callback_t)(cy_timer_callback_arg_t arg);
+
+/**
+ * Return the last error from the RTOS.
+ *
+ * The functions in the RTOS abstraction layer adhere to the Cypress return
+ * results calling convention.  The underlying RTOS implementations will not but rather
+ * will have their own error code conventions.  This function is provided as a service
+ * to the developer, mostly for debugging, and returns the underlying RTOS error code
+ * from the last RTOS abstraction layer that returned CY_RTOS_GENERAL_ERROR.
+ *
+ * @return RTOS specific error code.
+ * 
+ * \ingroup group_abstraction_rtos_common
+ */
+cy_rtos_error_t cy_rtos_last_error();
+
+/*********************************************** Threads **********************************************/
+
+/*
+ * 
+ * \ingroup group_abstraction_rtos_threads
+ * \{
+ */
+
+/** Create a thread with specific thread argument.
+ *
+ * This function is called to startup a new thread. If the thread can exit, it must call
+ * cy_rtos_finish_thread() just before doing so. All created threds that can terminate, either
+ * by themselves or forcefully by another thread MUST be joined in order to cleanup any resources
+ * that might have been allocated for them.
+ *
+ * @param[out] thread         Pointer to a variable which will receive the new thread handle
+ * @param[in]  entry_function Function pointer which points to the main function for the new thread
+ * @param[in]  name           String thread name used for a debugger
+ * @param[in]  stack          The buffer to use for the thread stack. This must be aligned to
+ *                            CY_RTOS_ALIGNMENT with a size of at least CY_RTOS_MIN_STACK_SIZE.
+ *                            If stack is null, cy_rtos_create_thread will allocate a stack from the heap.
+ * @param[in]  stack_size     The size of the thread stack in bytes
+ * @param[in]  priority       The priority of the thread. Values are operating system specific, but some
+ *                            common priority levels are defined:
+ *                                CY_THREAD_PRIORITY_LOW
+ *                                CY_THREAD_PRIORITY_NORMAL
+ *                                CY_THREAD_PRIORITY_HIGH
+ * @param[in]  arg            The argument to pass to the new thread
+ *
+ * @return The status of thread create request. [CY_RSLT_SUCCESS, CY_RTOS_NO_MEMORY, CY_RTOS_GENERAL_ERROR]
+ */
+cy_rslt_t cy_rtos_create_thread(cy_thread_t *thread, cy_thread_entry_fn_t entry_function,
+            const char *name, void *stack, uint32_t stack_size, cy_thread_priority_t priority, cy_thread_arg_t arg);
+
+
+/** Exit the current thread.
+ *
+ * This function is called just before a thread exits.  In some cases it is sufficient
+ * for a thread to just return to exit, but in other cases, the RTOS must be explicitly
+ * signaled. In cases where a return is sufficient, this should be a null funcition.
+ * where the RTOS must be signaled, this function should perform that In cases operation.
+ * In code using RTOS services, this function should be placed at any at any location
+ * where the main thread function will return, exiting the thread. Threads that can
+ * exit must still be joined (cy_rtos_join_thread) to ensure their resources are fully
+ * cleaned up.
+ *
+ * @return The status of thread exit request. [CY_RSLT_SUCCESS, CY_RTOS_GENERAL_ERROR]
+ */
+cy_rslt_t cy_rtos_exit_thread();
+
+/** Terminates another thread.
+ *
+ * This function is called to terminate another thread and reap the resoruces claimed
+ * by it thread. This should be called both when forcibly terminating another thread
+ * as well as any time a thread can exit on its own. For some RTOS implementations
+ * this is not required as the thread resoruces are claimed as soon as it exits. In
+ * other cases, this must be called to reclaim resources. Threads that are terminated
+ * must still be joined (cy_rtos_join_thread) to ensure their resources are fully
+ * cleaned up.
+ *
+ * @param[in] thread Handle of the thread to terminate
+ *
+ * @returns The status of the thread terminate. [CY_RSLT_SUCCESS, CY_RTOS_GENERAL_ERROR]
+ */
+cy_rslt_t cy_rtos_terminate_thread(cy_thread_t *thread);
+
+/** Waits for a thread to complete.
+ *
+ * This must be called on any thread that can complete to ensure that any resources that
+ * were allocated for it are cleaned up.
+ *
+ * @param[in] thread Handle of the thread to wait for
+ *
+ * @returns The status of thread join request. [CY_RSLT_SUCCESS, CY_RTOS_GENERAL_ERROR]
+ */
+cy_rslt_t cy_rtos_join_thread(cy_thread_t *thread);
+
+/** Checks if the thread is running
+ *
+ * This function is called to determine if a thread is running or not. For information on
+ * the thread state, use the cy_rtos_get_thread_state() function.
+ *
+ * @param[in] thread     Handle of the terminated thread to delete
+ * @param[out] running   Returns true if the thread is running, otherwise false
+ *
+ * @returns The status of the thread running check. [CY_RSLT_SUCCESS, CY_RTOS_GENERAL_ERROR]
+ */
+cy_rslt_t cy_rtos_is_thread_running(cy_thread_t *thread, bool *running);
+
+/** Gets the state the thread is currently in
+ *
+ * This function is called to determine if a thread is running/blocked/inactive/ready etc.
+ *
+ * @param[in] thread     Handle of the terminated thread to delete
+ * @param[out] state     Returns the state the thread is currently in
+ *
+ * @returns The status of the thread state check. [CY_RSLT_SUCCESS, CY_RTOS_GENERAL_ERROR]
+ */
+cy_rslt_t cy_rtos_get_thread_state(cy_thread_t *thread, cy_thread_state_t *state);
+
+/** Get current thread handle
+ *
+ * Returns the unique thread handle of the current running thread.
+ *
+ * @param[out] thread Handle of the current running thread
+ *
+ * @returns The status of thread join request. [CY_RSLT_SUCCESS, CY_RTOS_GENERAL_ERROR]
+ */
+cy_rslt_t cy_rtos_get_thread_handle(cy_thread_t *thread);
+
+/** \} group_abstraction_rtos_threads */
+
+/*********************************************** Mutexes **********************************************/
+
+/**
+  * \ingroup group_abstraction_rtos_mutex
+  * \{
+  */
+
+/** Create a mutex.
+ *
+ * This is basically a binary mutex which can be used to synchronize between threads
+ * and between threads and ISRs.
+ *
+ * @param[out] mutex Pointer to the mutex handle to be initialized
+ *
+ * @return The status of mutex creation request. [CY_RSLT_SUCCESS, CY_RTOS_NO_MEMORY, CY_RTOS_GENERAL_ERROR]
+ */
+cy_rslt_t cy_rtos_init_mutex(cy_mutex_t *mutex);
+
+/** Get a mutex.
+ *
+ * If the mutex is available, it is acquired and this function returned.
+ * If the mutex is not available, the thread waits until the mutex is available
+ * or until the timeout occurs.
+ *
+ * @note This function must not be called from an interrupt context as it may block.
+ *
+ * @param[in] mutex       Pointer to the mutex handle
+ * @param[in] timeout_ms  Maximum number of milliseconds to wait while attempting to get
+ *                        the mutex. Use the NEVER_TIMEOUT constant to wait forever. Must
+ *                        be zero is in_isr is true
+ *
+ * @return The status of the get mutex. Returns timeout if mutex was not acquired
+ *                    before timeout_ms period. [CY_RSLT_SUCCESS, CY_RTOS_TIMEOUT]
+ */
+cy_rslt_t cy_rtos_get_mutex(cy_mutex_t *mutex, cy_time_t timeout_ms);
+
+/** Set a mutex.
+ *
+ * The mutex is released allowing any other threads waiting on the mutex to
+ * obtain the sempahore.
+ *
+ * @param[in] mutex   Pointer to the mutex handle
+ *
+ * @return The status of the set mutex request. [CY_RSLT_SUCCESS, CY_RTOS_TIMEOUT]
+ *
+ */
+cy_rslt_t cy_rtos_set_mutex(cy_mutex_t *mutex);
+
+/** Deletes a mutex.
+ *
+ * This function frees the resources associated with a sempahore.
+ *
+ * @param[in] mutex Pointer to the mutex handle
+ *
+ * @return The status to the delete request. [CY_RSLT_SUCCESS, CY_RTOS_TIMEOUT]
+ */
+cy_rslt_t cy_rtos_deinit_mutex(cy_mutex_t *mutex);
+
+/** \} group_abstraction_rtos_mutex */
+
+/*********************************************** Semaphores **********************************************/
+
+/**
+  * \ingroup group_abstraction_rtos_semaphore
+  * \{
+  */
+
+/**
+ * Create a semaphore
+ *
+ * This is basically a counting semaphore.
+ *
+ * @param[in,out] semaphore  Pointer to the semaphore handle to be initialized
+ * @param[in] maxcount       The maximum count for this semaphore
+ * @param[in] initcount      The initial count for this sempahore
+ *
+ * @return The status of the sempahore creation. [CY_RSLT_SUCCESS, CY_RTOS_NO_MEMORY, CY_RTOS_GENERAL_ERROR]
+ */
+cy_rslt_t cy_rtos_init_semaphore(cy_semaphore_t *semaphore, uint32_t maxcount, uint32_t initcount);
+
+/**
+ * Get/Acquire a semaphore
+ *
+ * If the semaphore count is zero, waits until the semaphore count is greater than zero.
+ * Once the semaphore count is greater than zero, this function decrements
+ * the count and return.  It may also return if the timeout is exceeded.
+ *
+ * @param[in] semaphore   Pointer to the semaphore handle
+ * @param[in] timeout_ms  Maximum number of milliseconds to wait while attempting to get
+ *                        the semaphore. Use the NEVER_TIMEOUT constant to wait forever. Must
+ *                        be zero is in_isr is true
+ * @param[in] in_isr      true if we are trying to get the semaphore from with an ISR
+ * @return The status of get semaphore operation [CY_RSLT_SUCCESS, CY_RTOS_NO_MEMORY, CY_RTOS_GENERAL_ERROR]
+ */
+cy_rslt_t cy_rtos_get_semaphore(cy_semaphore_t *semaphore, cy_time_t timeout_ms, bool in_isr);
+
+/**
+ * Set/Release a semaphore
+ *
+ * Increments the semaphore count, up to the maximum count for this semaphore.
+ *
+ * @param[in] semaphore   Pointer to the semaphore handle
+ * @param[in] in_isr      Value of true indicates calling from interrupt context
+ *                        Value of false indicates calling from normal thread context
+ * @return The status of set semaphore operation [CY_RSLT_SUCCESS, CY_RTOS_NO_MEMORY, CY_RTOS_GENERAL_ERROR]
+ */
+cy_rslt_t cy_rtos_set_semaphore(cy_semaphore_t *semaphore, bool in_isr);
+
+/**
+ * Deletes a sempahore
+ *
+ * This function frees the resources associated with a sempahore.
+ *
+ * @param[in] semaphore   Pointer to the sempahore handle
+ *
+ * @return The status of semaphore deletion [CY_RSLT_SUCCESS, CY_RTOS_NO_MEMORY, CY_RTOS_GENERAL_ERROR]
+ */
+cy_rslt_t cy_rtos_deinit_semaphore(cy_semaphore_t *semaphore);
+
+/** \} group_abstraction_rtos_semaphore */
+
+/*********************************************** Events **********************************************/
+
+/** 
+  * \ingroup group_abstraction_rtos_event
+  * \{
+  */
+
+/** Create an event.
+ *
+ * This is an event which can be used to signal a set of threads
+ * with a 32 bit data element.
+ *
+ * @param[in,out] event Pointer to the event handle to be initialized
+ *
+ * @return The status of the event initialization request.
+ *         [CY_RSLT_SUCCESS, CY_RTOS_NO_MEMORY, CY_RTOS_GENERAL_ERROR]
+ */
+cy_rslt_t cy_rtos_init_event(cy_event_t *event);
+
+/** Set the event flag bits.
+ *
+ * This is an event which can be used to signal a set of threads
+ * with a 32 bit data element. Any threads waiting on this event are released
+ *
+ * @param[in] event  Pointer to the event handle
+ * @param[in] bits   The value of the 32 bit flags
+ * @param[in] in_isr If true, this is called from an ISR, otherwise from a thread
+ *
+ * @return The status of the set request. [CY_RSLT_SUCCESS, CY_RTOS_NO_MEMORY, CY_RTOS_GENERAL_ERROR]
+ */
+cy_rslt_t cy_rtos_setbits_event(cy_event_t *event, uint32_t bits, bool in_isr) ;
+
+/**
+ * Clear the event flag bits
+ *
+ * This function clears bits in the event.
+ *
+ * @param[in] event   Pointer to the event handle
+ * @param[in] bits    Any bits set in this value, will be cleared in the event.
+ * @param[in] in_isr  if true, this is called from an ISR, otherwise from a thread
+ *
+ * @return The status of the clear flags request. [CY_RSLT_SUCCESS, CY_RTOS_NO_MEMORY, CY_RTOS_GENERAL_ERROR]
+ */
+cy_rslt_t cy_rtos_clearbits_event(cy_event_t *event, uint32_t bits, bool in_isr) ;
+
+/** Get the event bits.
+ *
+ * Returns the current bits for the event.
+ *
+ * @param[in]  event Pointer to the event handle
+ * @param[out] bits  pointer to receive the value of the event flags
+ *
+ * @return The status of the get request. [CY_RSLT_SUCCESS, CY_RTOS_NO_MEMORY, CY_RTOS_GENERAL_ERROR]
+ */
+cy_rslt_t cy_rtos_getbits_event(cy_event_t *event, uint32_t *bits);
+
+/** Wait for the event and return bits.
+ *
+ * Waits for the event to be set and then returns the bits assocaited
+ * with the event, or waits for the given timeout period.
+ * @note This function returns if any bit in the set is set.
+ *
+ * @param[in] event     Pointer to the event handle
+ * @param[in,out] bits  pointer to receive the value of the event flags
+ * @param[in] clear     if true, clear any bits set that cause the wait to return
+ *                      if false, do not clear bits
+ * @param[in] all       if true, all bits in the initial bits value must be set to return
+ *                      if false, any one bit in the initial bits value must be set to return
+ * @param[in] timeout   The amount of time to wait in milliseconds
+ *
+ * @return The status of the wait for event request. [CY_RSLT_SUCCESS, CY_RTOS_NO_MEMORY, CY_RTOS_GENERAL_ERROR]
+ */
+cy_rslt_t cy_rtos_waitbits_event(cy_event_t *event, uint32_t *bits, bool clear, bool all, cy_time_t timeout);
+
+/** Deinitialize a event.
+ *
+ * This function frees the resources associated with an event.
+ *
+ * @param[in] event Pointer to the event handle
+ *
+ * @return The status of the deletion request. [CY_RSLT_SUCCESS, CY_RTOS_GENERAL_ERROR]
+ */
+cy_rslt_t cy_rtos_deinit_event(cy_event_t *event);
+
+/** \} group_abstraction_rtos_event */
+
+/*********************************************** Queues **********************************************/
+
+/** 
+  * \ingroup group_abstraction_rtos_queue 
+  * \{
+  */
+
+/** Create a queue.
+ *
+ * This is a queue of data where entries are placed on the back of the queue
+ * and removed from the front of the queue.
+ *
+ * @param[out] queue    Pointer to the queue handle
+ * @param[in]  length   The maximum length of the queue in items
+ * @param[in]  itemsize The size of each item in the queue.
+ *
+ * @return The status of the creation request. [CY_RSLT_SUCCESS, CY_RTOS_NO_MEMORY, CY_RTOS_GENERAL_ERROR]
+ */
+cy_rslt_t cy_rtos_init_queue(cy_queue_t *queue, size_t length, size_t itemsize);
+
+/** Put an item in a queue.
+ *
+ * This function puts an item in the queue. The item is copied
+ * into the queue using a memory copy and the data pointed to by item_ptr
+ * is no longer referenced once the call returns.
+ *
+ * @note If in_isr is true, timeout_ms must be zero.
+ *
+ * @param[in] queue      Pointer to the queue handle
+ * @param[in] item_ptr   Pointer to the item to place in the queue
+ * @param[in] timeout_ms The time to wait to place the item in the queue
+ * @param[in] in_isr     If true this is being called from within and ISR
+ *
+ * @return The status of the creation request. [CY_RSLT_SUCCESS, CY_RTOS_NO_MEMORY, CY_RTOS_GENERAL_ERROR, CY_RTOS_QUEUE_FULL]
+ */
+cy_rslt_t cy_rtos_put_queue(cy_queue_t *queue, const void *item_ptr, cy_time_t timeout_ms, bool in_isr);
+
+/** Gets an item in a queue.
+ *
+ * This function gets an item fropm the queue. The item is copied
+ * out of the queue into the memory provide by item_ptr. This space must be
+ * large enough to hold a queue entry as defined when the queue was initialized.
+ *
+ * @note If in_isr is true, timeout_ms must be zero.
+ *
+ * @param[in] queue     Pointer to the queue handle
+ * @param[in] item_ptr  Pointer to the memory for the item from the queue
+ * @param[in] timeout_ms The time to wait to place the item in the queue
+ * @param[in] in_isr    If true this is being called from within and ISR
+ *
+ * @return The status of the creation request. [CY_RSLT_SUCCESS, CY_RTOS_NO_MEMORY, CY_RTOS_GENERAL_ERROR, CY_RTOS_QUEUE_EMPTY]
+ */
+cy_rslt_t cy_rtos_get_queue(cy_queue_t *queue, void *item_ptr, cy_time_t timeout_ms, bool in_isr);
+
+/** Return the number of items in the queue.
+ *
+ * This function returns the number of items currently in the queue.
+ *
+ * @param[in]  queue       Pointer to the queue handle
+ * @param[out] num_waiting Pointer to the return count
+ *
+ * @return The status of the creation request. [CY_RSLT_SUCCESS, CY_RTOS_GENERAL_ERROR]
+ */
+cy_rslt_t cy_rtos_count_queue(cy_queue_t *queue, size_t *num_waiting);
+
+/** Return the amount of empty space in the queue.
+ *
+ * This function returns the amount of empty space in the
+ * queue. For instance, if the queue was created with 10 entries max and there
+ * are currently 2 entries in the queue, this will return 8.
+ *
+ * @param[in]  queue      Pointer to the queue handle
+ * @param[out] num_spaces Pointer to the return count.
+ *
+ * @return The status of the creation request. [CY_RSLT_SUCCESS, CY_RTOS_GENERAL_ERROR]
+ */
+cy_rslt_t cy_rtos_space_queue(cy_queue_t *queue, size_t *num_spaces);
+
+/** Reset the queue.
+ *
+ * This function sets the queue to empty.
+ *
+ * @param[in] queue pointer to the queue handle
+ *
+ * @return The status of the creation request. [CY_RSLT_SUCCESS, CY_RTOS_GENERAL_ERROR]
+ */
+cy_rslt_t cy_rtos_reset_queue(cy_queue_t *queue);
+
+/** Deinitialize the queue handle.
+ *
+ * This function deinitializes the queue and returns all
+ * resources used by the queue.
+ *
+ * @param[in] queue Pointer to the queue handle
+ *
+ * @return The status of the creation request. [CY_RSLT_SUCCESS, CY_RTOS_GENERAL_ERROR]
+ */
+cy_rslt_t cy_rtos_deinit_queue(cy_queue_t *queue);
+
+/** \} group_abstraction_rtos_queue */
+
+/*********************************************** Timers **********************************************/
+
+/**
+  * \ingroup group_abstraction_rtos_timer
+  * \{
+  */
+
+/** Create a new timer.
+ *
+ * This function intializes a timer object. @note The timer is
+ * not active until start is called.
+ *
+ * @param[out] timer Pointer to the timer handle to initalize
+ * @param[in]  type  Type of timer (periodic or once)
+ * @param[in]  fun   The functiuon
+ * @param[in]  arg   Argument to pass along to the callback function
+ *
+ * @return The status of the creation request. [CY_RSLT_SUCCESS, CY_RTOS_GENERAL_ERROR]
+ */
+cy_rslt_t cy_rtos_init_timer(cy_timer_t *timer, cy_timer_trigger_type_t type,
+        cy_timer_callback_t fun, cy_timer_callback_arg_t arg);
+
+/** Start a timer.
+ *
+ * @note The callback may be (likely will be) called from a different thread.
+ *
+ * @param[in] timer  Pointer to the timer handle
+ * @param[in] num_ms The number of miliseconds to wait before the timer fires
+ *
+ * @return The status of the creation request. [CY_RSLT_SUCCESS, CY_RTOS_GENERAL_ERROR]
+ */
+cy_rslt_t cy_rtos_start_timer(cy_timer_t *timer, cy_time_t num_ms);
+
+/** Stop a timer.
+ *
+ * @param[in] timer Pointer to the timer handle
+ *
+ * @return The status of the creation request. [CY_RSLT_SUCCESS, CY_RTOS_GENERAL_ERROR]
+ */
+cy_rslt_t cy_rtos_stop_timer(cy_timer_t *timer);
+
+/** Returns state of a timer.
+ *
+ * @param[in]  timer Pointer to the timer handle
+ * @param[out] state Return value for state, true if running, false otherwise
+ *
+ * @return The status of the creation request. [CY_RSLT_SUCCESS, CY_RTOS_GENERAL_ERROR]
+ */
+cy_rslt_t cy_rtos_is_running_timer(cy_timer_t *timer, bool *state);
+
+/** Deinit the timer.
+ *
+ * This function de initializes the timer and frees all consumed
+ * resources.
+ *
+ * @param[in] timer Pointer to the timer handle
+ *
+ * @return The status of the creation request. [CY_RSLT_SUCCESS, CY_RTOS_GENERAL_ERROR]
+ */
+cy_rslt_t cy_rtos_deinit_timer(cy_timer_t *timer);
+
+/** \} group_abstraction_rtos_timer */
+
+/*********************************************** Time **********************************************/
+
+/**
+  * \ingroup group_abstraction_rtos_time
+  * \{
+  */
+
+/** Gets time in milliseconds since RTOS start.
+ *
+ * @note Since this is only 32 bits, it will roll over every 49 days, 17 hours, 2 mins, 47.296 seconds
+ *
+ * @param[out] tval Pointer to the struct to populate with the RTOS time
+ *
+ * @returns Time in milliseconds since the RTOS started.
+ */
+cy_rslt_t cy_rtos_get_time(cy_time_t *tval);
+
+/** Delay for a number of milliseconds.
+ *
+ * Processing of this function depends on the minimum sleep
+ * time resolution of the RTOS. The current thread should sleep for
+ * the longest period possible which is less than the delay required,
+ * then makes up the difference with a tight loop.
+ *
+ * @param[in] num_ms The number of miliseconds to delay for
+ *
+ * @return The status of the creation request. [CY_RSLT_SUCCESS, CY_RTOS_GENERAL_ERROR]
+ */
+cy_rslt_t cy_rtos_delay_milliseconds(cy_time_t num_ms);
+
+/** \} group_abstraction_rtos_timer */
+
+#ifdef __cplusplus
+} /* extern "C" */
+#endif
+#endif /* ifndef INCLUDED_CY_RTOS_INTERFACE_H_ */
+
diff --git a/targets/TARGET_STM/TARGET_STM32H7/TARGET_STM32H747xI/TARGET_PORTENTA_H7/COMPONENT_WHD/interface/cyabs_rtos_impl.h b/targets/TARGET_STM/TARGET_STM32H7/TARGET_STM32H747xI/TARGET_PORTENTA_H7/COMPONENT_WHD/interface/cyabs_rtos_impl.h
new file mode 100644
index 0000000000..bb0f4767ec
--- /dev/null
+++ b/targets/TARGET_STM/TARGET_STM32H7/TARGET_STM32H747xI/TARGET_PORTENTA_H7/COMPONENT_WHD/interface/cyabs_rtos_impl.h
@@ -0,0 +1,77 @@
+/***************************************************************************//**
+* \file cyabs_rtos_impl.h
+*
+* \brief
+* Internal definitions for RTOS abstraction layer
+*
+********************************************************************************
+* \copyright
+* Copyright 2019 Cypress Semiconductor Corporation
+* SPDX-License-Identifier: Apache-2.0
+*
+* Licensed under the Apache License, Version 2.0 (the "License");
+* you may not use this file except in compliance with the License.
+* You may obtain a copy of the License at
+*
+*     http://www.apache.org/licenses/LICENSE-2.0
+*
+* Unless required by applicable law or agreed to in writing, software
+* distributed under the License is distributed on an "AS IS" BASIS,
+* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+* See the License for the specific language governing permissions and
+* limitations under the License.
+*/
+
+
+#ifndef INCLUDED_CYABS_RTOS_IMPL_H_
+#define INCLUDED_CYABS_RTOS_IMPL_H_
+
+#include "cmsis_os2.h"
+#include "rtx_os.h"
+
+#ifdef __cplusplus
+extern "C"
+{
+#endif
+
+/******************************************************
+*                 Constants
+******************************************************/
+#define CY_RTOS_MIN_STACK_SIZE      300                     /** Minimum stack size */
+#define CY_RTOS_ALIGNMENT           0x00000008UL            /** Minimum alignment for RTOS objects */
+#define CY_RTOS_ALIGNMENT_MASK      0x00000007UL            /** Mask for checking the alignement of crated RTOS objects */
+
+
+/******************************************************
+*                 Type Definitions
+******************************************************/
+
+/* RTOS thread priority */
+typedef enum
+{
+    CY_RTOS_PRIORITY_MIN = osPriorityNone,
+    CY_RTOS_PRIORITY_LOW = osPriorityLow,
+    CY_RTOS_PRIORITY_BELOWNORMAL = osPriorityBelowNormal,
+    CY_RTOS_PRIORITY_NORMAL = osPriorityNormal,
+    CY_RTOS_PRIORITY_ABOVENORMAL = osPriorityAboveNormal,
+    CY_RTOS_PRIORITY_HIGH = osPriorityHigh,
+    CY_RTOS_PRIORITY_REALTIME = osPriorityRealtime,
+    CY_RTOS_PRIORITY_MAX = osPriorityRealtime7
+} cy_thread_priority_t ;
+
+typedef osThreadId_t cy_thread_t;                      /** CMSIS definition of a thread handle */
+typedef void * cy_thread_arg_t;                        /** Argument passed to the entry function of a thread */
+typedef osMutexId_t cy_mutex_t;                        /** CMSIS definition of a mutex */
+typedef osSemaphoreId_t cy_semaphore_t;                /** CMSIS definition of a semaphore */
+typedef osEventFlagsId_t cy_event_t;                   /** CMSIS definition of an event */
+typedef osMessageQueueId_t cy_queue_t;                 /** CMSIS definition of a message queue */
+typedef osTimerId_t cy_timer_t;                        /** CMSIS definition of a timer */
+typedef uint32_t cy_timer_callback_arg_t;              /** Argument passed to the timer callback function */
+typedef uint32_t cy_time_t;                            /** Time in milliseconds */
+typedef osStatus_t cy_rtos_error_t;                    /** CMSIS definition of a error status */
+
+#ifdef __cplusplus
+} /* extern "C" */
+#endif
+#endif /* ifndef INCLUDED_CYABS_RTOS_IMPL_H_ */
+
diff --git a/targets/TARGET_STM/TARGET_STM32H7/TARGET_STM32H747xI/TARGET_PORTENTA_H7/COMPONENT_WHD/interface/cyabs_rtos_rtxv5.c b/targets/TARGET_STM/TARGET_STM32H7/TARGET_STM32H747xI/TARGET_PORTENTA_H7/COMPONENT_WHD/interface/cyabs_rtos_rtxv5.c
new file mode 100644
index 0000000000..37de65f971
--- /dev/null
+++ b/targets/TARGET_STM/TARGET_STM32H7/TARGET_STM32H747xI/TARGET_PORTENTA_H7/COMPONENT_WHD/interface/cyabs_rtos_rtxv5.c
@@ -0,0 +1,828 @@
+/***************************************************************************//**
+* \file cyabs_rtos.c
+*
+* \brief
+* Implementation for CMSIS RTOS v2 abstraction
+*
+********************************************************************************
+* \copyright
+* Copyright 2018-2019 Cypress Semiconductor Corporation
+* SPDX-License-Identifier: Apache-2.0
+*
+* Licensed under the Apache License, Version 2.0 (the "License");
+* you may not use this file except in compliance with the License.
+* You may obtain a copy of the License at
+*
+*     http://www.apache.org/licenses/LICENSE-2.0
+*
+* Unless required by applicable law or agreed to in writing, software
+* distributed under the License is distributed on an "AS IS" BASIS,
+* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+* See the License for the specific language governing permissions and
+* limitations under the License.
+*******************************************************************************/
+
+#include <stdlib.h>
+#include <assert.h>
+#include "cyabs_rtos.h"
+
+#if defined(__cplusplus)
+extern "C" {
+#endif
+
+
+/******************************************************
+*                 Error Converter
+******************************************************/
+
+/* Last received error status */
+static cy_rtos_error_t dbgErr;
+cy_rtos_error_t cy_rtos_last_error() { return dbgErr; }
+
+/* Converts internal error type to external error type */
+static cy_rslt_t error_converter(cy_rtos_error_t internalError)
+{
+    cy_rslt_t value;
+
+    switch (internalError)
+    {
+        case osOK:
+            value = CY_RSLT_SUCCESS;
+            break;
+        case osErrorTimeout:
+            value = CY_RTOS_TIMEOUT;
+            break;
+        case osErrorParameter:
+            value = CY_RTOS_BAD_PARAM;
+            break;
+        case osErrorNoMemory:
+            value = CY_RTOS_NO_MEMORY;
+            break;
+        case osError:
+        case osErrorResource:
+        case osErrorISR:
+        default:
+            value = CY_RTOS_GENERAL_ERROR;
+            break;
+    }
+
+    /* Update the last known error status */
+    dbgErr = internalError;
+    return value;
+}
+
+
+/******************************************************
+*                 Threads
+******************************************************/
+
+cy_rslt_t cy_rtos_create_thread(cy_thread_t *thread, cy_thread_entry_fn_t entry_function,
+            const char *name, void *stack, uint32_t stack_size, cy_thread_priority_t priority, cy_thread_arg_t arg)
+{
+    cy_rslt_t status = CY_RSLT_SUCCESS;
+    osThreadAttr_t attr;
+
+    if (thread == NULL || stack_size < CY_RTOS_MIN_STACK_SIZE)
+        status = CY_RTOS_BAD_PARAM;
+    else
+    {
+        attr.name = name;
+        attr.attr_bits = osThreadJoinable;
+        attr.cb_size = osRtxThreadCbSize;
+        attr.stack_size = stack_size;
+        attr.priority = (osPriority_t)priority;
+        attr.tz_module = 0;
+        attr.reserved = 0;
+
+        /* Allocate stack if NULL was passed */
+        if ((uint32_t *)stack == NULL)
+        {
+            /* Note: 1 malloc so that it can be freed with 1 call when terminating */
+            uint32_t cb_mem_pad = (~osRtxThreadCbSize + 1) & CY_RTOS_ALIGNMENT_MASK;
+            attr.cb_mem = malloc(osRtxThreadCbSize + cb_mem_pad + stack_size);
+            if (attr.cb_mem != NULL)
+                attr.stack_mem = (uint32_t *)((uint32_t)attr.cb_mem + osRtxThreadCbSize + cb_mem_pad);
+        }
+        else
+        {
+            attr.cb_mem = malloc(osRtxThreadCbSize);
+            attr.stack_mem = stack;
+        }
+
+        if (attr.cb_mem == NULL)
+            status = CY_RTOS_NO_MEMORY;
+        else
+        {
+            assert(((uint32_t)attr.cb_mem & CY_RTOS_ALIGNMENT_MASK) == 0UL);
+            assert(((uint32_t)attr.stack_mem & CY_RTOS_ALIGNMENT_MASK) == 0UL);
+            *thread = osThreadNew((osThreadFunc_t)entry_function, (void *)arg, &attr );
+            assert((*thread == attr.cb_mem) || (*thread == NULL));
+            status = (*thread == NULL) ? CY_RTOS_GENERAL_ERROR : CY_RSLT_SUCCESS;
+        }
+    }
+
+    return status;
+}
+
+cy_rslt_t cy_rtos_exit_thread()
+{
+    osThreadExit();
+}
+
+cy_rslt_t cy_rtos_terminate_thread(cy_thread_t *thread)
+{
+    cy_rslt_t status;
+    cy_rtos_error_t statusInternal;
+
+    if (thread == NULL)
+        status = CY_RTOS_BAD_PARAM;
+    else
+    {
+        statusInternal = osThreadTerminate(*thread);
+        status = error_converter(statusInternal);
+    }
+
+    return status;
+}
+
+cy_rslt_t cy_rtos_is_thread_running(cy_thread_t *thread, bool *running)
+{
+    cy_rslt_t status = CY_RSLT_SUCCESS;
+
+    if ((thread == NULL) || (running == NULL))
+        status = CY_RTOS_BAD_PARAM;
+    else
+    {
+        *running = (osThreadGetState(*thread) == osThreadRunning) ? true : false;
+    }
+
+    return status;
+}
+
+cy_rslt_t cy_rtos_get_thread_state(cy_thread_t *thread, cy_thread_state_t *state)
+{
+    cy_rslt_t status = CY_RSLT_SUCCESS;
+
+    if ((thread == NULL) || (state == NULL))
+        status = CY_RTOS_BAD_PARAM;
+    else
+    {
+        switch (osThreadGetState(*thread))
+        {
+            case osThreadInactive:
+                *state = CY_THREAD_STATE_INACTIVE;
+                break;
+            case osThreadReady:
+                *state = CY_THREAD_STATE_READY;
+                break;
+            case osThreadRunning:
+                *state = CY_THREAD_STATE_RUNNING;
+                break;
+            case osThreadBlocked:
+                *state = CY_THREAD_STATE_BLOCKED;
+                break;
+            case osThreadTerminated:
+                *state = CY_THREAD_STATE_TERMINATED;
+                break;
+            case osThreadError:
+            case osThreadReserved:
+            default:
+                *state = CY_THREAD_STATE_UNKNOWN;
+                break;
+        }
+    }
+
+    return status;
+}
+
+cy_rslt_t cy_rtos_join_thread(cy_thread_t *thread)
+{
+    cy_rslt_t status;
+    cy_rtos_error_t statusInternal;
+
+    if (thread == NULL)
+        status = CY_RTOS_BAD_PARAM;
+    else
+    {
+        statusInternal = osThreadJoin(*thread);
+        status = error_converter(statusInternal);
+
+        if (status == CY_RSLT_SUCCESS)
+        {
+            free(*thread);
+            *thread = NULL;
+        }
+    }
+
+    return status;
+}
+
+
+/******************************************************
+*                 Mutexes
+******************************************************/
+
+cy_rslt_t cy_rtos_init_mutex(cy_mutex_t *mutex)
+{
+    cy_rslt_t status;
+    osMutexAttr_t attr;
+
+    if (mutex == NULL)
+        status = CY_RTOS_BAD_PARAM;
+    else
+    {
+        attr.name = NULL;
+        attr.attr_bits = osMutexRecursive | osMutexPrioInherit;
+        attr.cb_mem = malloc(osRtxMutexCbSize);
+        attr.cb_size = osRtxMutexCbSize;
+
+        if (attr.cb_mem == NULL)
+            status = CY_RTOS_NO_MEMORY;
+        else
+        {
+            assert(((uint32_t)attr.cb_mem & CY_RTOS_ALIGNMENT_MASK) == 0UL);
+            *mutex = osMutexNew(&attr);
+            assert((*mutex == attr.cb_mem) || (*mutex == NULL));
+            status = (*mutex == NULL) ? CY_RTOS_GENERAL_ERROR : CY_RSLT_SUCCESS;
+        }
+    }
+
+    return status;
+}
+
+cy_rslt_t cy_rtos_get_mutex(cy_mutex_t *mutex, cy_time_t timeout_ms)
+{
+    cy_rslt_t status;
+    cy_rtos_error_t statusInternal;
+
+    if (mutex == NULL)
+        status = CY_RTOS_BAD_PARAM;
+    else
+    {
+        statusInternal = osMutexAcquire(*mutex, timeout_ms);
+        status = error_converter(statusInternal);
+    }
+
+    return status;
+}
+
+cy_rslt_t cy_rtos_set_mutex(cy_mutex_t *mutex)
+{
+    cy_rslt_t status;
+    cy_rtos_error_t statusInternal;
+
+    if (mutex == NULL)
+        status = CY_RTOS_BAD_PARAM;
+    else
+    {
+        statusInternal = osMutexRelease(*mutex);
+        status = error_converter(statusInternal);
+    }
+
+    return status;
+}
+
+cy_rslt_t cy_rtos_deinit_mutex(cy_mutex_t *mutex)
+{
+    cy_rslt_t status;
+    cy_rtos_error_t statusInternal;
+
+    if (mutex == NULL)
+        status = CY_RTOS_BAD_PARAM;
+    else
+    {
+        statusInternal = osMutexDelete(*mutex);
+        status = error_converter(statusInternal);
+
+        if (status == CY_RSLT_SUCCESS)
+        {
+            free(*mutex);
+            *mutex = NULL;
+        }
+    }
+
+    return status;
+}
+
+
+/******************************************************
+*                 Semaphores
+******************************************************/
+
+cy_rslt_t cy_rtos_init_semaphore(cy_semaphore_t *semaphore, uint32_t maxcount, uint32_t initcount)
+{
+    cy_rslt_t status;
+    osSemaphoreAttr_t attr;
+
+    if (semaphore == NULL)
+        status = CY_RTOS_BAD_PARAM;
+    else
+    {
+        attr.name = NULL;
+        attr.attr_bits = 0U;
+        attr.cb_mem = malloc(osRtxSemaphoreCbSize);
+        attr.cb_size = osRtxSemaphoreCbSize;
+
+        if (attr.cb_mem == NULL)
+            status = CY_RTOS_NO_MEMORY;
+        else
+        {
+            assert(((uint32_t)attr.cb_mem & CY_RTOS_ALIGNMENT_MASK) == 0UL);
+            *semaphore = osSemaphoreNew(maxcount, initcount, &attr);
+            assert((*semaphore == attr.cb_mem) || (*semaphore == NULL));
+            status = (*semaphore == NULL) ? CY_RTOS_GENERAL_ERROR : CY_RSLT_SUCCESS;
+        }
+    }
+
+    return status;
+}
+
+cy_rslt_t cy_rtos_get_semaphore(cy_semaphore_t *semaphore, cy_time_t timeout_ms, bool in_isr)
+{
+    cy_rslt_t status = CY_RSLT_SUCCESS;
+    cy_rtos_error_t statusInternal;
+
+    if (semaphore == NULL)
+        status = CY_RTOS_BAD_PARAM;
+    else
+    {
+        /* Not allowed to be called in ISR if timeout != 0 */
+        if ((!in_isr) || (in_isr && (timeout_ms == 0U)))
+            statusInternal = osSemaphoreAcquire(*semaphore, timeout_ms);
+        else
+            statusInternal = osErrorISR;
+
+        status = error_converter(statusInternal);
+    }
+
+    return status;
+}
+
+cy_rslt_t cy_rtos_set_semaphore(cy_semaphore_t *semaphore, bool in_isr)
+{
+    cy_rslt_t status = CY_RSLT_SUCCESS;
+    cy_rtos_error_t statusInternal;
+    (void)in_isr; // Unused parameter in this implementation
+
+    if (semaphore == NULL)
+        status = CY_RTOS_BAD_PARAM;
+    else
+    {
+        statusInternal = osSemaphoreRelease(*semaphore);
+        status = error_converter(statusInternal);
+    }
+
+    return status;
+}
+
+cy_rslt_t cy_rtos_deinit_semaphore(cy_semaphore_t *semaphore)
+{
+    cy_rslt_t status;
+    cy_rtos_error_t statusInternal;
+
+    if (semaphore == NULL)
+        status = CY_RTOS_BAD_PARAM;
+    else
+    {
+        statusInternal = osSemaphoreDelete(*semaphore);
+        status = error_converter(statusInternal);
+        if (status == CY_RSLT_SUCCESS)
+        {
+            free(*semaphore);
+            *semaphore = NULL;
+        }
+    }
+
+    return status;
+}
+
+
+/******************************************************
+*                 Events
+******************************************************/
+
+#define CY_RTOS_EVENT_ERRORFLAG		0x80000000UL
+#define CY_RTOS_EVENT_FLAGS 		0x7FFFFFFFUL
+
+cy_rslt_t cy_rtos_init_event(cy_event_t *event)
+{
+    cy_rslt_t status;
+    osEventFlagsAttr_t attr;
+
+    if (event == NULL)
+        status = CY_RTOS_BAD_PARAM;
+    else
+    {
+        attr.name = NULL;
+        attr.attr_bits = 0U;
+        attr.cb_mem = malloc(osRtxEventFlagsCbSize);
+        attr.cb_size = osRtxEventFlagsCbSize;
+
+        if (attr.cb_mem == NULL)
+            status = CY_RTOS_NO_MEMORY;
+        else
+        {
+            assert(((uint32_t)attr.cb_mem & CY_RTOS_ALIGNMENT_MASK) == 0UL);
+            *event = osEventFlagsNew(&attr);
+            assert((*event == attr.cb_mem) || (*event == NULL));
+            status = (*event == NULL) ? CY_RTOS_GENERAL_ERROR : CY_RSLT_SUCCESS;
+        }
+    }
+
+    return status;
+}
+
+cy_rslt_t cy_rtos_setbits_event(cy_event_t *event, uint32_t bits, bool in_isr)
+{
+    cy_rslt_t status = CY_RSLT_SUCCESS;
+    cy_rtos_error_t statusInternal;
+    (void)in_isr; // Unused parameter in this implementation
+
+    if (event == NULL)
+        status = CY_RTOS_BAD_PARAM;
+    else
+    {
+        statusInternal = (osStatus_t)osEventFlagsSet(*event, bits);
+        if ((statusInternal & CY_RTOS_EVENT_ERRORFLAG) != 0UL)
+            status = error_converter(statusInternal);
+    }
+
+    return status;
+}
+
+cy_rslt_t cy_rtos_clearbits_event(cy_event_t *event, uint32_t bits, bool in_isr)
+{
+    cy_rslt_t status = CY_RSLT_SUCCESS;
+    cy_rtos_error_t statusInternal;
+    (void)in_isr; // Unused parameter in this implementation
+
+    if (event == NULL)
+        status = CY_RTOS_BAD_PARAM;
+    else
+    {
+        statusInternal = (osStatus_t)osEventFlagsClear(*event, bits);
+        if ((statusInternal & CY_RTOS_EVENT_ERRORFLAG) != 0UL)
+            status = error_converter(statusInternal);
+    }
+
+    return status;
+}
+
+cy_rslt_t cy_rtos_getbits_event(cy_event_t *event, uint32_t *bits)
+{
+    cy_rslt_t status = CY_RSLT_SUCCESS;
+
+    if ((event == NULL) || (bits == NULL))
+        status = CY_RTOS_BAD_PARAM;
+    else
+        *bits = osEventFlagsGet(*event);
+
+    return status;
+}
+
+cy_rslt_t cy_rtos_waitbits_event(cy_event_t *event, uint32_t *bits, bool clear, bool all, cy_time_t timeout)
+{
+    cy_rslt_t status = CY_RSLT_SUCCESS;
+    cy_rtos_error_t statusInternal;
+    uint32_t flagOption;
+
+    if ((event == NULL) || (bits == NULL))
+        status = CY_RTOS_BAD_PARAM;
+    else
+    {
+        flagOption = (all) ? osFlagsWaitAll : osFlagsWaitAny;
+        if (!clear)
+            flagOption |= osFlagsNoClear;
+
+        statusInternal = (osStatus_t)osEventFlagsWait(*event, *bits, flagOption, timeout);
+        if ((statusInternal & CY_RTOS_EVENT_ERRORFLAG) == 0UL)
+            *bits = statusInternal;
+        else
+            status = error_converter(statusInternal);
+    }
+
+    return status;
+}
+
+cy_rslt_t cy_rtos_deinit_event(cy_event_t *event)
+{
+    cy_rslt_t status;
+    cy_rtos_error_t statusInternal;
+
+    if (event == NULL)
+        status = CY_RTOS_BAD_PARAM;
+    else
+    {
+        statusInternal = osEventFlagsDelete(*event);
+        status = error_converter(statusInternal);
+        if (status == CY_RSLT_SUCCESS)
+        {
+            free(*event);
+            *event = NULL;
+        }
+    }
+
+    return status;
+}
+
+
+/******************************************************
+*                 Queues
+******************************************************/
+
+cy_rslt_t cy_rtos_init_queue(cy_queue_t *queue, size_t length, size_t itemsize)
+{
+    cy_rslt_t status;
+    osMessageQueueAttr_t attr;
+
+    if (queue == NULL)
+        status = CY_RTOS_BAD_PARAM;
+    else
+    {
+        attr.name = NULL;
+        attr.attr_bits = 0U;
+        attr.cb_size = osRtxMessageQueueCbSize;
+        uint32_t blockSize = ((itemsize + 3U) & ~3UL) + sizeof(osRtxMessage_t);
+        attr.mq_size = blockSize * length;
+
+        /* Note: 1 malloc for both so that they can be freed with 1 call */
+        uint32_t cb_mem_pad = (8 - (osRtxMessageQueueCbSize & 0x07)) & 0x07;
+        attr.cb_mem = malloc(osRtxMessageQueueCbSize + cb_mem_pad + attr.mq_size);
+        if (attr.cb_mem != NULL)
+            attr.mq_mem = (uint32_t *)((uint32_t)attr.cb_mem + osRtxMessageQueueCbSize + cb_mem_pad);
+
+        if (attr.cb_mem == NULL)
+            status = CY_RTOS_NO_MEMORY;
+        else
+        {
+            assert(((uint32_t)attr.cb_mem & CY_RTOS_ALIGNMENT_MASK) == 0UL);
+            assert(((uint32_t)attr.mq_mem & CY_RTOS_ALIGNMENT_MASK) == 0UL);
+            *queue = osMessageQueueNew(length, itemsize, &attr);
+            assert((*queue == attr.cb_mem) || (*queue == NULL));
+            status = (*queue == NULL) ? CY_RTOS_GENERAL_ERROR : CY_RSLT_SUCCESS;
+        }
+    }
+
+    return status;
+}
+
+cy_rslt_t cy_rtos_put_queue(cy_queue_t *queue, const void *item_ptr, cy_time_t timeout_ms, bool in_isr)
+{
+    cy_rslt_t status;
+    cy_rtos_error_t statusInternal;
+
+    if ((queue == NULL) || (item_ptr == NULL))
+        status = CY_RTOS_BAD_PARAM;
+    else
+    {
+        /* Not allowed to be called in ISR if timeout != 0 */
+        if ((!in_isr) || (in_isr && (timeout_ms == 0U)))
+            statusInternal = osMessageQueuePut(*queue, (uint8_t *)item_ptr, 0u, timeout_ms);
+        else
+            statusInternal = osErrorISR;
+
+        status = error_converter(statusInternal);
+    }
+
+    return status;
+}
+
+cy_rslt_t cy_rtos_get_queue(cy_queue_t *queue, void *item_ptr, cy_time_t timeout_ms, bool in_isr)
+{
+    cy_rslt_t status;
+    cy_rtos_error_t statusInternal;
+
+    if ((queue == NULL) || (item_ptr == NULL))
+        status = CY_RTOS_BAD_PARAM;
+    else
+    {
+        /* Not allowed to be called in ISR if timeout != 0 */
+        if ((!in_isr) || (in_isr && (timeout_ms == 0U)))
+            statusInternal = osMessageQueueGet(*queue, (uint8_t *)item_ptr, 0u, timeout_ms);
+        else
+            statusInternal = osErrorISR;
+
+        status = error_converter(statusInternal);
+    }
+
+    return status;
+}
+
+cy_rslt_t cy_rtos_count_queue(cy_queue_t *queue, size_t *num_waiting)
+{
+    cy_rslt_t status = CY_RSLT_SUCCESS;
+
+    if ((queue == NULL) || (num_waiting == NULL))
+        status = CY_RTOS_BAD_PARAM;
+    else
+        *num_waiting = osMessageQueueGetCount(*queue);
+
+    return status;
+}
+
+cy_rslt_t cy_rtos_space_queue(cy_queue_t *queue, size_t *num_spaces)
+{
+    cy_rslt_t status = CY_RSLT_SUCCESS;
+
+    if ((queue == NULL) || (num_spaces == NULL))
+        status = CY_RTOS_BAD_PARAM;
+    else
+        *num_spaces = osMessageQueueGetSpace(*queue);
+
+    return status;
+}
+
+cy_rslt_t cy_rtos_reset_queue(cy_queue_t *queue)
+{
+    cy_rslt_t status;
+    cy_rtos_error_t statusInternal;
+
+    if (queue == NULL)
+        status = CY_RTOS_BAD_PARAM;
+    else
+    {
+        statusInternal = osMessageQueueReset(*queue);
+        status = error_converter(statusInternal);
+    }
+
+    return status;
+}
+
+cy_rslt_t cy_rtos_deinit_queue(cy_queue_t *queue)
+{
+    cy_rslt_t status;
+    cy_rtos_error_t statusInternal;
+
+    if (queue == NULL)
+        status = CY_RTOS_BAD_PARAM;
+    else
+    {
+        statusInternal = osMessageQueueDelete(*queue);
+        status = error_converter(statusInternal);
+
+        if (status == CY_RSLT_SUCCESS)
+        {
+            free(*queue);
+            *queue = NULL;
+        }
+    }
+
+    return status;
+}
+
+
+/******************************************************
+*                 Timers
+******************************************************/
+
+cy_rslt_t cy_rtos_init_timer(cy_timer_t *timer, cy_timer_trigger_type_t type,
+        cy_timer_callback_t fun, cy_timer_callback_arg_t arg)
+{
+    cy_rslt_t status;
+    osTimerAttr_t attr;
+
+    if (timer == NULL)
+        status = CY_RTOS_BAD_PARAM;
+    else
+    {
+        attr.name = NULL;
+        attr.attr_bits = 0U;
+        attr.cb_mem = malloc(osRtxTimerCbSize);
+        attr.cb_size = osRtxTimerCbSize;
+
+        if (attr.cb_mem == NULL)
+            status = CY_RTOS_NO_MEMORY;
+        else
+        {
+            osTimerType_t osTriggerType = (CY_TIMER_TYPE_PERIODIC == type)
+                ? osTimerPeriodic
+                : osTimerOnce;
+
+            assert(((uint32_t)attr.cb_mem & CY_RTOS_ALIGNMENT_MASK) == 0UL);
+            *timer = osTimerNew( (osTimerFunc_t)fun, osTriggerType, (void *)arg, &attr );
+            assert((*timer == attr.cb_mem) || (*timer == NULL));
+            status = (*timer == NULL) ? CY_RTOS_GENERAL_ERROR : CY_RSLT_SUCCESS;
+        }
+    }
+
+    return status;
+}
+
+cy_rslt_t cy_rtos_start_timer(cy_timer_t *timer, cy_time_t num_ms)
+{
+    cy_rslt_t status;
+    cy_rtos_error_t statusInternal;
+
+    if (timer == NULL)
+        status = CY_RTOS_BAD_PARAM;
+    else
+    {
+        /* Get Number of ticks per second */
+        uint32_t tick_freq = osKernelGetTickFreq();
+
+        /* Convert ticks count to time in milliseconds */
+        if (tick_freq != 0)
+        {
+            uint32_t ticks = ((num_ms * tick_freq) / 1000);
+            statusInternal = osTimerStart(*timer, ticks);
+            status = error_converter(statusInternal);
+        }
+        else
+            status = CY_RTOS_GENERAL_ERROR;
+    }
+
+    return status;
+}
+
+cy_rslt_t cy_rtos_stop_timer(cy_timer_t *timer)
+{
+    cy_rslt_t status;
+    cy_rtos_error_t statusInternal;
+
+    if (timer == NULL)
+        status = CY_RTOS_BAD_PARAM;
+    else
+    {
+        statusInternal = osTimerStop(*timer);
+        status = error_converter(statusInternal);
+    }
+
+    return status;
+}
+
+cy_rslt_t cy_rtos_is_running_timer(cy_timer_t *timer, bool *state)
+{
+    cy_rslt_t status = CY_RSLT_SUCCESS;
+
+    if ((timer == NULL) || (state == NULL))
+        status = CY_RTOS_BAD_PARAM;
+    else
+        *state = osTimerIsRunning(*timer);
+
+    return status;
+}
+
+cy_rslt_t cy_rtos_deinit_timer(cy_timer_t *timer)
+{
+    cy_rslt_t status;
+    cy_rtos_error_t statusInternal;
+
+    if (timer == NULL)
+        status = CY_RTOS_BAD_PARAM;
+    else
+    {
+        statusInternal = osTimerDelete(*timer);
+        status = error_converter(statusInternal);
+
+        if (status == CY_RSLT_SUCCESS)
+        {
+            free(*timer);
+            *timer = NULL;
+        }
+    }
+
+    return status;
+}
+
+
+/******************************************************
+*                 Time
+******************************************************/
+
+cy_rslt_t cy_rtos_get_time(cy_time_t *tval)
+{
+    cy_rslt_t status = CY_RSLT_SUCCESS;
+    uint32_t tick_freq;
+
+    if (tval == NULL)
+        status = CY_RTOS_BAD_PARAM;
+    else
+    {
+        /* Get Number of ticks per second */
+        tick_freq = osKernelGetTickFreq();
+
+        /* Convert ticks count to time in milliseconds */
+        if (tick_freq != 0)
+            *tval = (cy_time_t)((osKernelGetTickCount() * 1000LL) / tick_freq);
+        else
+            status = CY_RTOS_GENERAL_ERROR;
+    }
+
+    return status;
+}
+
+cy_rslt_t cy_rtos_delay_milliseconds(cy_time_t num_ms)
+{
+    cy_rslt_t status;
+    cy_rtos_error_t statusInternal;
+
+    statusInternal = osDelay(num_ms);
+    status = error_converter(statusInternal);
+
+    return status;
+}
+
+
+#if defined(__cplusplus)
+}
+#endif
diff --git a/targets/TARGET_STM/TARGET_STM32H7/TARGET_STM32H747xI/TARGET_PORTENTA_H7/COMPONENT_WHD/interface/cyhal_gpio.cpp b/targets/TARGET_STM/TARGET_STM32H7/TARGET_STM32H747xI/TARGET_PORTENTA_H7/COMPONENT_WHD/interface/cyhal_gpio.cpp
new file mode 100644
index 0000000000..a0fa5ffbc3
--- /dev/null
+++ b/targets/TARGET_STM/TARGET_STM32H7/TARGET_STM32H747xI/TARGET_PORTENTA_H7/COMPONENT_WHD/interface/cyhal_gpio.cpp
@@ -0,0 +1,83 @@
+/*
+ * Copyright 2020 Arduino SA
+ * SPDX-License-Identifier: Apache-2.0
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+/** @file
+ *  Provides the porting layer for STM32 GPIOs on WHD driver
+ */
+
+#include "cyhal_gpio.h"
+#include "mbed.h"
+
+extern pinconfig_t      PinConfig[];
+
+static mbed::InterruptIn* oob_irq;
+static cyhal_gpio_irq_event_t oob_event = CYHAL_GPIO_IRQ_FALL;
+static cyhal_gpio_irq_handler_t oob_handler;
+static void* oob_handler_arg;
+
+static void cb() {
+  oob_handler(oob_handler_arg, oob_event);
+}
+
+void cyhal_gpio_register_irq(cyhal_gpio_t pin, uint8_t intrPriority, cyhal_gpio_irq_handler_t handler,
+                             void *handler_arg)
+{
+  if (handler && handler_arg && (oob_irq==NULL)) {
+    oob_irq = new mbed::InterruptIn(PJ_5);
+    oob_handler = handler;
+    oob_handler_arg = handler_arg;
+  }
+}
+
+void cyhal_gpio_irq_enable(cyhal_gpio_t pin, cyhal_gpio_irq_event_t event, bool enable)
+{
+  oob_event = event;
+  if (enable) {
+    if (CYHAL_GPIO_IRQ_RISE) {
+      oob_irq->rise(cb);
+    }
+    if (CYHAL_GPIO_IRQ_FALL) {
+      oob_irq->fall(cb);
+    }
+  } else if (oob_irq != NULL) {
+    delete oob_irq;
+  }
+}
+
+
+#include <stdio.h>
+
+cy_rslt_t cyhal_gpio_init(cyhal_gpio_t pin, cyhal_gpio_direction_t direction, cyhal_gpio_drive_mode_t drvMode, bool initVal)
+{
+  cy_rslt_t     ret= CY_RSLT_SUCCESS;
+   // printf("Port Init %s %d\n",PinConfig[pin].portname, PinConfig[pin].pinnumber);
+
+  /* Ignore the parameter and take the pin config directly from a static array defintions */
+  HAL_GPIO_Init(PinConfig[pin].port, &PinConfig[pin].config);
+  if (direction == CYHAL_GPIO_DIR_OUTPUT) HAL_GPIO_WritePin(PinConfig[pin].port, PinConfig[pin].config.Pin, (initVal)?GPIO_PIN_SET:GPIO_PIN_RESET);
+  //if (direction == CYHAL_GPIO_DIR_OUTPUT)   printf("Port %s %s %d\n",(initVal)?"High":"low",PinConfig[pin].portname, PinConfig[pin].pinnumber);
+
+  return ret;
+}
+
+
+
+void cyhal_gpio_write(cyhal_gpio_t pin, bool value)
+{
+  /*printf("Port %s %s %d\n",(value)?"High":"low",PinConfig[pin].portname, PinConfig[pin].pinnumber);*/
+  HAL_GPIO_WritePin(PinConfig[pin].port, PinConfig[pin].config.Pin, (value)?GPIO_PIN_SET:GPIO_PIN_RESET);
+}
diff --git a/targets/TARGET_STM/TARGET_STM32H7/TARGET_STM32H747xI/TARGET_PORTENTA_H7/COMPONENT_WHD/interface/cyhal_gpio.h b/targets/TARGET_STM/TARGET_STM32H7/TARGET_STM32H747xI/TARGET_PORTENTA_H7/COMPONENT_WHD/interface/cyhal_gpio.h
new file mode 100644
index 0000000000..c741cab1ab
--- /dev/null
+++ b/targets/TARGET_STM/TARGET_STM32H7/TARGET_STM32H747xI/TARGET_PORTENTA_H7/COMPONENT_WHD/interface/cyhal_gpio.h
@@ -0,0 +1,208 @@
+/***************************************************************************//**
+* \file cyhal_gpio.h
+*
+* \brief
+* Provides a high level interface for interacting with the Cypress GPIO.
+* This interface abstracts out the chip specific details. If any chip specific
+* functionality is necessary, or performance is critical the low level functions
+* can be used directly.
+*
+********************************************************************************
+* \copyright
+* Copyright 2018-2019 Cypress Semiconductor Corporation
+* SPDX-License-Identifier: Apache-2.0
+*
+* Licensed under the Apache License, Version 2.0 (the "License");
+* you may not use this file except in compliance with the License.
+* You may obtain a copy of the License at
+*
+*     http://www.apache.org/licenses/LICENSE-2.0
+*
+* Unless required by applicable law or agreed to in writing, software
+* distributed under the License is distributed on an "AS IS" BASIS,
+* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+* See the License for the specific language governing permissions and
+* limitations under the License.
+*******************************************************************************/
+
+/**
+ * \addtogroup group_hal_gpio GPIO (General Purpose Input Output)
+ * \ingroup group_hal
+ * \{
+ * High level interface for interacting with the Cypress GPIO.
+ *
+ * \defgroup group_hal_gpio_macros Macros
+ * \defgroup group_hal_gpio_functions Functions
+ * \defgroup group_hal_gpio_data_structures Data Structures
+ * \defgroup group_hal_gpio_enums Enumerated Types
+ */
+
+#pragma once
+
+#include <stdint.h>
+#include <stdbool.h>
+#include "cy_result.h"
+#include "cyhal_hw_types.h"
+
+#if defined(__cplusplus)
+extern "C" {
+#endif /* __cplusplus */
+
+/*******************************************************************************
+*       Defines
+*******************************************************************************/
+
+/**
+ * \addtogroup group_hal_gpio_macros
+ * \{
+ */
+
+/** Integer representation of no connect pin (required to exist in all BSPs) */
+#define CYHAL_NC_PIN_VALUE ( (cyhal_gpio_t)0xFFFFFFFF )
+
+/** \} group_hal_gpio_macros */
+
+
+/**
+ * \addtogroup group_hal_gpio_enums
+ * \{
+ */
+
+/*******************************************************************************
+*       Enumerations
+*******************************************************************************/
+
+/** Pin IRQ events */
+typedef enum
+{
+    CYHAL_GPIO_IRQ_NONE = 0,   /**< No interrupt */
+    CYHAL_GPIO_IRQ_RISE = 1,   /**< Interrupt on rising edge */
+    CYHAL_GPIO_IRQ_FALL = 2,   /**< Interrupt on falling edge */
+    CYHAL_GPIO_IRQ_BOTH = 3,   /**< Interrupt on both rising and falling edges */
+} cyhal_gpio_irq_event_t;
+
+/** Pin direction */
+typedef enum
+{
+    CYHAL_GPIO_DIR_INPUT         = 0,  /**< Input pin */
+    CYHAL_GPIO_DIR_OUTPUT        = 1,  /**< Output pin */
+    CYHAL_GPIO_DIR_BIDIRECTIONAL = 2,   /**< Input and output pin */
+} cyhal_gpio_direction_t;
+
+/** Pin drive mode */
+typedef enum
+{
+    CYHAL_GPIO_DRIVE_NONE                = 0, /**< No drive; Hi-Z */
+    CYHAL_GPIO_DRIVE_ANALOG              = 0, /**< Analog Hi-Z */
+    CYHAL_GPIO_DRIVE_PULLUP              = 2, /**< Pull-up resistor */
+    CYHAL_GPIO_DRIVE_PULLDOWN            = 3, /**< Pull-down resistor */
+    CYHAL_GPIO_DRIVE_OPENDRAINDRIVESLOW  = 4, /**< Open-drain, Drives Low */
+    CYHAL_GPIO_DRIVE_OPENDRAINDRIVESHIGH = 5, /**< Open-drain, Drives High */
+    CYHAL_GPIO_DRIVE_STRONG              = 6, /**< Strong output */
+    CYHAL_GPIO_DRIVE_PULLUPDOWN          = 7, /**< Pull-up and pull-down resistors */
+} cyhal_gpio_drive_mode_t;
+
+/** \} group_hal_gpio_enums */
+
+
+/**
+ * \addtogroup group_hal_gpio_data_structures
+ * \{
+ */
+
+/** GPIO callback function type */
+typedef void (*cyhal_gpio_irq_handler_t)(void *handler_arg, cyhal_gpio_irq_event_t event);
+
+/** \} group_hal_gpio_data_structures */
+
+
+/**
+ * \addtogroup group_hal_gpio_functions
+ * \{
+ */
+
+/*******************************************************************************
+*       Functions
+*******************************************************************************/
+
+/** Initialize the GPIO pin
+ *
+ * @param[in]  pin The GPIO pin to initialize
+ * @param[in]  direction The pin direction (input/output)
+ * @param[in]  drvMode The pin drive mode
+ * @param[in]  initVal Initial value on the pin
+ *
+ * @return The status of the init request
+ */
+cy_rslt_t cyhal_gpio_init(cyhal_gpio_t pin, cyhal_gpio_direction_t direction, cyhal_gpio_drive_mode_t drvMode,
+                          bool initVal);
+
+/** Uninitialize the gpio peripheral and the cyhal_gpio_t object
+ *
+ * @param[in] pin Pin number
+ */
+void cyhal_gpio_free(cyhal_gpio_t pin);
+
+/** Set the pin direction
+ *
+ * @param[in] pin       The pin number
+ * @param[in] direction The pin direction to be set
+ * @return The status of the dir request
+ */
+cy_rslt_t cyhal_gpio_direction(cyhal_gpio_t pin, cyhal_gpio_direction_t direction);
+
+/** Set the input pin mode
+ *
+ * @param[in] pin  The GPIO object
+ * @param[in] drvMode The pin mode to be set
+ *
+ * @return The status of the mode request
+ */
+cy_rslt_t cyhal_gpio_drivemode(cyhal_gpio_t pin, cyhal_gpio_drive_mode_t drvMode);
+
+/** Set the output value for the pin. This only works for output & in_out pins.
+ *
+ * @param[in] pin   The GPIO object
+ * @param[in] value The value to be set (high = true, low = false)
+ */
+void cyhal_gpio_write(cyhal_gpio_t pin, bool value);
+
+/** Read the input value.  This only works for input & in_out pins.
+ *
+ * @param[in]  pin   The GPIO object
+ * @return The value of the IO (true = high, false = low)
+ */
+bool cyhal_gpio_read(cyhal_gpio_t pin);
+
+/** Toggle the output value
+ *
+ * @param[in]  pin   The GPIO object
+ */
+void cyhal_gpio_toggle(cyhal_gpio_t pin);
+
+/** Register/clear an interrupt handler for the pin toggle pin IRQ event
+ *
+ * @param[in] pin           The pin number
+ * @param[in] intrPriority  The NVIC interrupt channel priority
+ * @param[in] handler       The function to call when the specified event happens. Pass NULL to unregister the handler.
+ * @param[in] handler_arg   Generic argument that will be provided to the handler when called, can be NULL
+ */
+void cyhal_gpio_register_irq(cyhal_gpio_t pin, uint8_t intrPriority, cyhal_gpio_irq_handler_t handler,
+                             void *handler_arg);
+
+/** Enable or Disable the GPIO IRQ
+ *
+ * @param[in] pin    The GPIO object
+ * @param[in] event  The GPIO IRQ event
+ * @param[in] enable True to turn on interrupts, False to turn off
+ */
+void cyhal_gpio_irq_enable(cyhal_gpio_t pin, cyhal_gpio_irq_event_t event, bool enable);
+
+/** \} group_hal_gpio_functions */
+
+#ifdef __cplusplus
+}
+#endif /* __cplusplus */
+
+/** \} group_hal_gpio */
+
diff --git a/targets/TARGET_STM/TARGET_STM32H7/TARGET_STM32H747xI/TARGET_PORTENTA_H7/COMPONENT_WHD/interface/cyhal_hw_types.h b/targets/TARGET_STM/TARGET_STM32H7/TARGET_STM32H747xI/TARGET_PORTENTA_H7/COMPONENT_WHD/interface/cyhal_hw_types.h
new file mode 100644
index 0000000000..0436834aff
--- /dev/null
+++ b/targets/TARGET_STM/TARGET_STM32H7/TARGET_STM32H747xI/TARGET_PORTENTA_H7/COMPONENT_WHD/interface/cyhal_hw_types.h
@@ -0,0 +1,103 @@
+/***************************************************************************//**
+* \file cyhal_hw_types_template.h
+*
+* \brief
+* Provides a template for configuration resources used by the HAL. Items
+* here need to be implemented for each HAL port. It is up to the environment
+* being ported into what the actual types are. There are some suggestions below
+* but these are not required. All that is required is that the type is defined;
+* it does not matter to the HAL what type is actually chosen for the
+* implementation
+* All TODOs and references to 'PORT' need to be replaced by with meaningful
+* values for the device being supported.
+*
+********************************************************************************
+* \copyright
+* Copyright 2018-2019 Cypress Semiconductor Corporation
+* SPDX-License-Identifier: Apache-2.0
+*
+* Licensed under the Apache License, Version 2.0 (the "License");
+* you may not use this file except in compliance with the License.
+* You may obtain a copy of the License at
+*
+*     http://www.apache.org/licenses/LICENSE-2.0
+*
+* Unless required by applicable law or agreed to in writing, software
+* distributed under the License is distributed on an "AS IS" BASIS,
+* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+* See the License for the specific language governing permissions and
+* limitations under the License.
+*******************************************************************************/
+
+/**
+ * \addtogroup group_hal_hw_types PORT Hardware Types
+ * \ingroup group_hal_PORT
+ * \{
+ * Struct definitions for configuration resources in the PORT.
+ *
+ * \defgroup group_hal_hw_types_data_structures Data Structures
+ */
+
+#pragma once
+#include <stdbool.h>
+#include "stm32h7xx_hal.h"
+
+/*
+ #include "TODO: Port specific header file"
+ */
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/**
+ * \addtogroup group_hal_hw_types_data_structures
+ * \{
+ */
+
+typedef int32_t  cyhal_gpio_t;
+
+/** GPIO object */
+typedef struct
+{
+  GPIO_TypeDef      *port;
+  GPIO_InitTypeDef  config;
+} pinconfig_t;
+
+/** Clock divider object */
+typedef struct
+{
+    /* TODO: replace with port specific items */
+    void *div_type;
+} cyhal_clock_divider_t;
+
+/** SDIO object */
+typedef   void*  *cyhal_sdio_t;
+
+/** SPI object */
+typedef struct
+{
+    /* TODO: replace with port specific items */
+    void *empty;
+} cyhal_spi_t;
+
+
+#include "whd_debug.h"
+
+#if defined(WPRINT_ENABLE_WHD_ERROR) || defined(WPRINT_ENABLE_WHD_INFO) || defined(WPRINT_ENABLE_WHD_DEBUG)
+/** \} group_hal_hw_types_data_structures */
+#define PRINTF(...)   do { \
+                      (void) printf(__VA_ARGS__); \
+                      } while (0)
+#else
+#define PRINTF(...)
+#endif
+
+#include "whd_config.h"
+
+#if defined(__cplusplus)
+}
+#endif /* __cplusplus */
+
+/** \} group_hal_hw_types */
+
diff --git a/targets/TARGET_STM/TARGET_STM32H7/TARGET_STM32H747xI/TARGET_PORTENTA_H7/COMPONENT_WHD/interface/cyhal_modules.h b/targets/TARGET_STM/TARGET_STM32H7/TARGET_STM32H747xI/TARGET_PORTENTA_H7/COMPONENT_WHD/interface/cyhal_modules.h
new file mode 100644
index 0000000000..e95f8e13ab
--- /dev/null
+++ b/targets/TARGET_STM/TARGET_STM32H7/TARGET_STM32H747xI/TARGET_PORTENTA_H7/COMPONENT_WHD/interface/cyhal_modules.h
@@ -0,0 +1,86 @@
+/***************************************************************************//**
+* \file cyhal_modules.h
+*
+* \brief
+* Provides an enum of all HAL modules types that can be used for generating
+* custom cy_rslt_t items.
+*
+********************************************************************************
+* \copyright
+* Copyright 2018-2019 Cypress Semiconductor Corporation
+* SPDX-License-Identifier: Apache-2.0
+*
+* Licensed under the Apache License, Version 2.0 (the "License");
+* you may not use this file except in compliance with the License.
+* You may obtain a copy of the License at
+*
+*     http://www.apache.org/licenses/LICENSE-2.0
+*
+* Unless required by applicable law or agreed to in writing, software
+* distributed under the License is distributed on an "AS IS" BASIS,
+* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+* See the License for the specific language governing permissions and
+* limitations under the License.
+*******************************************************************************/
+
+/**
+ * \addtogroup group_hal_modules Driver Modules
+ * \ingroup group_hal
+ * \{
+ * Enum definition for all HAL resource modules.
+ *
+ * \defgroup group_hal_modules_enums Enumerated Types
+ */
+
+#pragma once
+
+#include "cy_result.h"
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+
+/**
+ * \addtogroup group_hal_modules_enums
+ * \{
+ */
+
+/** Enum to in indicate which module an errors occurred in. */
+enum cyhal_rslt_module_chip
+{
+    CYHAL_RSLT_MODULE_CHIP_HWMGR = CY_RSLT_MODULE_ABSTRACTION_HAL_BASE, //!< An error occurred in hardware management module
+    CYHAL_RSLT_MODULE_ADC,                                              //!< An error occurred in ADC module
+    CYHAL_RSLT_MODULE_COMP,                                             //!< An error occurred in comparator module
+    CYHAL_RSLT_MODULE_CRC,                                              //!< An error occurred in crypto CRC module
+    CYHAL_RSLT_MODULE_DAC,                                              //!< An error occurred in DAC module
+    CYHAL_RSLT_MODULE_DMA,                                              //!< An error occurred in DMA module
+    CYHAL_RSLT_MODULE_FLASH,                                            //!< An error occurred in flash module
+    CYHAL_RSLT_MODULE_GPIO,                                             //!< An error occurred in GPIO module
+    CYHAL_RSLT_MODULE_I2C,                                              //!< An error occurred in I2C module
+    CYHAL_RSLT_MODULE_I2S,                                              //!< An error occurred in I2S module
+    CYHAL_RSLT_MODULE_INTERCONNECT,                                     //!< An error occurred in Interconnct module
+    CYHAL_RSLT_MODULE_OPAMP,                                            //!< An error occurred in OpAmp module
+    CYHAL_RSLT_MODULE_PDMPCM,                                           //!< An error occurred in PDM/PCM module
+    CYHAL_RSLT_MODULE_PWM,                                              //!< An error occurred in PWM module
+    CYHAL_RSLT_MODULE_QSPI,                                             //!< An error occurred in QSPI module
+    CYHAL_RSLT_MODULE_RTC,                                              //!< An error occurred in RTC module
+    CYHAL_RSLT_MODULE_SDHC,                                             //!< An error occurred in SDHC module
+    CYHAL_RSLT_MODULE_SDIO,                                             //!< An error occurred in SDIO module
+    CYHAL_RSLT_MODULE_SPI,                                              //!< An error occurred in SPI module
+    CYHAL_RSLT_MODULE_SYSTEM,                                           //!< An error occurred in System module
+    CYHAL_RSLT_MODULE_TIMER,                                            //!< An error occurred in Timer module
+    CYHAL_RSLT_MODULE_TRNG,                                             //!< An error occurred in RNG module
+    CYHAL_RSLT_MODULE_UART,                                             //!< An error occurred in UART module
+    CYHAL_RSLT_MODULE_USB,                                              //!< An error occurred in USB module
+    CYHAL_RSLT_MODULE_WDT,                                              //!< An error occurred in WDT module
+};
+
+/** \} group_hal_modules_enums */
+
+#if defined(__cplusplus)
+}
+#endif /* __cplusplus */
+
+/** \} group_hal_modules */
+
diff --git a/targets/TARGET_STM/TARGET_STM32H7/TARGET_STM32H747xI/TARGET_PORTENTA_H7/COMPONENT_WHD/interface/cyhal_sdio.c b/targets/TARGET_STM/TARGET_STM32H7/TARGET_STM32H747xI/TARGET_PORTENTA_H7/COMPONENT_WHD/interface/cyhal_sdio.c
new file mode 100644
index 0000000000..13fa61536a
--- /dev/null
+++ b/targets/TARGET_STM/TARGET_STM32H7/TARGET_STM32H747xI/TARGET_PORTENTA_H7/COMPONENT_WHD/interface/cyhal_sdio.c
@@ -0,0 +1,800 @@
+/*
+ * Copyright 2020 Cypress Semiconductor Corporation
+ * SPDX-License-Identifier: Apache-2.0
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+/** @file
+ *  Provides the porting layer for STM32 SDIO on WHD driver
+ */
+
+#include <stdio.h>
+#include <string.h>
+#include "whd_thread.h"
+#include "bus_protocols/whd_bus_sdio_protocol.h"
+#include "cyabs_rtos.h"
+#include "cyhal_sdio.h"
+static int num=0;
+
+#define STM32H753xx
+
+#if defined (STM32H753xx)
+#define MEMCPY_RX
+#define COMMAND_FINISHED_CMD52_TIMEOUT_LOOPS (100000)
+#define COMMAND_FINISHED_CMD53_TIMEOUT_LOOPS (100000)
+#define SDIO_TX_RX_COMPLETE_TIMEOUT_LOOPS    (100000)
+//#define SDIO_1_BIT
+//#define SLOW_SDIO_CLOCK
+
+#else
+#define SLOW_SDIO_CLOCK
+
+#define COMMAND_FINISHED_CMD52_TIMEOUT_LOOPS (1000)
+#define COMMAND_FINISHED_CMD53_TIMEOUT_LOOPS (1000)
+#define SDIO_TX_RX_COMPLETE_TIMEOUT_LOOPS    (1000)
+#endif
+
+#if defined(STM32H753xx)
+#define SDIO_RESPONSE_SHORT             SDMMC_RESPONSE_SHORT
+#define SDIO_WAIT_NO                    SDMMC_WAIT_NO
+#define SDIO_CPSM_ENABLE                SDMMC_CPSM_ENABLE
+#define SDIO_CMDTRANS                   SDMMC_CMD_CMDTRANS
+#define SDIO_FLAG_CMDACT                (SDMMC_STA_CPSMACT | SDMMC_STA_DPSMACT)
+#define SDIO_TRANSFER_DIR_TO_SDIO       SDMMC_TRANSFER_DIR_TO_SDMMC
+#define SDIO_TRANSFER_DIR_TO_CARD       SDMMC_TRANSFER_DIR_TO_CARD
+#define SDIO_TRANSFER_MODE_BLOCK        SDMMC_TRANSFER_MODE_BLOCK
+#define SDIO_DPSM_ENABLE                SDMMC_DPSM_ENABLE
+#define SDIO_DPSM_DISABLE                SDMMC_DPSM_DISABLE
+#define SDIO_DCTRL_SDIOEN               SDMMC_DCTRL_SDIOEN       /* 1 << 11 */
+#define SDIO_DCTRL_DTMODE_1             SDMMC_DCTRL_DTMODE_1     /* 1<<3 */
+#define SDIO_STA_DTIMEOUT               SDMMC_STA_DTIMEOUT 
+#define SDIO_STA_CTIMEOUT               SDMMC_STA_CTIMEOUT
+#define SDIO_STA_CCRCFAIL               SDMMC_STA_CCRCFAIL
+#define SDIO_STA_DCRCFAIL               SDMMC_STA_DCRCFAIL
+#define SDIO_STA_TXUNDERR               SDMMC_STA_TXUNDERR
+#define SDIO_STA_RXOVERR                SDMMC_STA_RXOVERR
+#define SDIO_STA_TXACT                  SDMMC_STA_CPSMACT
+#define SDIO_STA_RXACT                  SDMMC_STA_DPSMACT
+#define SDIO_STA_CMDREND                SDMMC_STA_CMDREND
+#define SDIO_STA_CMDSENT                SDMMC_STA_CMDSENT
+#define SDIO_CMD_CMDTRANS               SDMMC_CMD_CMDTRANS
+#define SDIO    SDMMC1  
+
+#else
+#define SDIO_CMD_CMDTRANS               0
+#endif
+
+
+#define SDIO_DMA_TIMEOUT_LOOPS               (1000000)
+#define BUS_LEVEL_MAX_RETRIES                      10
+
+#define SDIO_CMD_5      5
+#define SDIO_CMD_53     53
+
+#define  SDIO_STA_STBITERR                   ((uint32_t)0x00000200)        /*!<Start bit not detected on all data signals in wide bus mode */
+
+
+#if defined(STM32F412xG)
+#define SDIO_ERROR_MASK                    ( SDIO_STA_DCRCFAIL | SDIO_STA_CTIMEOUT | SDIO_STA_DTIMEOUT | SDIO_STA_TXUNDERR | SDIO_STA_RXOVERR | SDIO_STA_STBITERR )
+#elif defined(STM32H753xx)
+#define SDIO_ERROR_MASK                    ( SDMMC_STA_CCRCFAIL | SDMMC_STA_DCRCFAIL | SDMMC_STA_CTIMEOUT | SDMMC_STA_DTIMEOUT | SDMMC_STA_TXUNDERR | SDMMC_STA_RXOVERR )
+#define SDMMC_MASK_SDIOTIE
+#else
+#define SDIO_ERROR_MASK                    ( SDIO_STA_CCRCFAIL | SDIO_STA_DCRCFAIL | SDIO_STA_CTIMEOUT | SDIO_STA_DTIMEOUT | SDIO_STA_TXUNDERR | SDIO_STA_RXOVERR | SDIO_STA_STBITERR )
+#endif
+
+
+
+#define LINK_MTU        1024
+#define MAX(a,b)        (a>b)?a:b
+
+
+
+extern pinconfig_t     PinConfig[];
+extern  SD_HandleTypeDef hsd;
+
+
+
+
+static whd_driver_t whd_handler;
+static cyhal_sdio_irq_handler_t sdio_irq_handler;
+
+#ifdef MEMCPY_RX
+static uint8_t       temp_dma_buffer[2048] __attribute__ ((aligned (8)));;
+#endif
+static uint8_t*                     user_data;
+static uint32_t                     user_data_size;
+static uint8_t*                     dma_data_source;
+static uint32_t                     dma_transfer_size;
+static  cyhal_transfer_t    current_transfer_direction;
+
+
+static  cy_semaphore_t sdio_transfer_finished_semaphore;
+volatile static uint32_t       sdio_transfer_failed=0;
+volatile static uint32_t       irqstatus=0;
+static int current_command=0;
+
+
+cy_rslt_t cyhal_sdio_init(cyhal_sdio_t *obj, cyhal_gpio_t cmd, cyhal_gpio_t clk, cyhal_gpio_t data0, cyhal_gpio_t data1,
+                          cyhal_gpio_t data2, cyhal_gpio_t data3)
+{
+  cy_rslt_t     ret= CY_RSLT_SUCCESS;
+  
+  __HAL_RCC_GPIOC_CLK_ENABLE();
+  __HAL_RCC_GPIOD_CLK_ENABLE();
+  __HAL_RCC_SDMMC1_CLK_ENABLE();
+
+  HAL_GPIO_Init(PinConfig[cmd].port, &PinConfig[cmd].config);
+  HAL_GPIO_Init(PinConfig[clk].port, &PinConfig[clk].config);
+  HAL_GPIO_Init(PinConfig[data0].port, &PinConfig[data0].config);
+  HAL_GPIO_Init(PinConfig[data1].port, &PinConfig[data1].config);
+  HAL_GPIO_Init(PinConfig[data2].port, &PinConfig[data2].config);
+  HAL_GPIO_Init(PinConfig[data3].port, &PinConfig[data3].config);
+
+#if defined(STM32H753xx)
+    /* Reset SDIO Block */
+    SDMMC_PowerState_OFF( SDMMC1 );
+    __HAL_RCC_SDMMC1_FORCE_RESET( );
+    __HAL_RCC_SDMMC1_RELEASE_RESET( );
+
+    /* Enable the SDIO Clock */
+    __HAL_RCC_SDMMC1_CLK_ENABLE( );
+#else
+    __HAL_RCC_SDIO_CLK_ENABLE();
+#endif
+
+  #if !(defined(DUAL_CORE) && defined(CORE_CM4))
+   /* Disable DCache for STM32H7 family */
+    SCB_CleanDCache();
+    SCB_DisableDCache();
+  #endif
+
+    //printf("in init: %d\n", sdio_transfer_finished_semaphore);
+    
+  // Lower  speed configuration
+#if defined(STM32H753xx)
+    
+ 
+    
+    SDMMC_InitTypeDef sdio_init_structure;
+
+    sdio_init_structure.ClockDiv            = SDMMC_INIT_CLK_DIV;
+    sdio_init_structure.ClockEdge           = SDMMC_CLOCK_EDGE_RISING;
+    sdio_init_structure.ClockPowerSave      = SDMMC_CLOCK_POWER_SAVE_DISABLE;
+    sdio_init_structure.BusWide             = SDMMC_BUS_WIDE_1B;
+    sdio_init_structure.HardwareFlowControl = SDMMC_HARDWARE_FLOW_CONTROL_DISABLE;
+    ret                              = SDMMC_Init( SDMMC1, sdio_init_structure );
+    ret                             |= SDMMC_PowerState_ON( SDMMC1 );
+    ret                             |= SDMMC_SetSDMMCReadWaitMode( SDMMC1, SDMMC_READ_WAIT_MODE_CLK );
+    if ( ret )
+    {
+        return ret;
+    }
+   
+    /* Clear all SDIO interrupts */
+    SDMMC1->ICR = (uint32_t) 0xffffffff;
+
+        /* Turn on SDIO IRQ */
+    /* Must be lower priority than the value of configMAX_SYSCALL_INTERRUPT_PRIORITY */
+    /* otherwise FreeRTOS will not be able to mask the interrupt */
+    /* keep in mind that ARMCM7 interrupt priority logic is inverted, the highest value */
+    /* is the lowest priority */
+    HAL_NVIC_EnableIRQ( (IRQn_Type) SDMMC1_IRQn );
+    HAL_NVIC_SetPriority(SDMMC1_IRQn, 5, 0);
+
+    //printf("after enable sdio: %d\n", sdio_transfer_finished_semaphore);
+
+
+#else
+  hsd.Instance = SDIO;
+  hsd.Init.ClockEdge = SDIO_CLOCK_EDGE_RISING;
+  hsd.Init.ClockBypass = SDIO_CLOCK_BYPASS_DISABLE;
+  hsd.Init.ClockPowerSave = SDIO_CLOCK_POWER_SAVE_DISABLE;
+  hsd.Init.ClockPowerSave = SDIO_CLOCK_POWER_SAVE_ENABLE;
+  hsd.Init.BusWide = SDIO_BUS_WIDE_1B;
+  hsd.Init.HardwareFlowControl = SDIO_HARDWARE_FLOW_CONTROL_DISABLE;
+  hsd.Init.ClockDiv = 120; /* 48Khz/ 120 =  400 Khz */
+ 
+  
+   /* Initialize SDIO peripheral interface with default configuration */
+  SDIO_Init(hsd.Instance, hsd.Init);
+  
+  /* Disable SDIO Clock */
+  __HAL_SD_DISABLE(&hsd); 
+  
+  /* Set Power State to ON */
+  SDIO_PowerState_ON(hsd.Instance);
+  
+   *(__IO uint32_t *) DCTRL_RWMOD_BB =  ((uint32_t)0x00000001);
+
+  /* Enable SDIO Clock */
+  __HAL_SD_ENABLE(&hsd);
+  
+  /* Required power up waiting time before starting the SD initialization sequence */
+  HAL_Delay(2U);
+  
+  /* Turn on SDIO IRQ */
+  SDIO->ICR = (uint32_t) 0xffffffff;
+
+  /* Must be lower priority than the value of configMAX_SYSCALL_INTERRUPT_PRIORITY */
+  /* otherwise FreeRTOS will not be able to mask the interrupt */
+  /* keep in mind that ARMCM3 interrupt priority logic is inverted, the highest value */
+  /* is the lowest priority */
+  NVIC_EnableIRQ( ( IRQn_Type ) SDIO_IRQn );
+  NVIC_EnableIRQ( ( IRQn_Type ) DMA2_Stream3_IRQn );
+
+  HAL_NVIC_SetPriority(SDIO_IRQn, 5, 0);
+  HAL_NVIC_SetPriority(DMA2_Stream3_IRQn, 5, 0);
+#endif
+
+  
+  
+  
+  
+  if (cy_rtos_init_semaphore(&sdio_transfer_finished_semaphore, 1, 0) != WHD_SUCCESS)
+  {
+    cy_rtos_deinit_semaphore(&sdio_transfer_finished_semaphore);
+    return -1;
+  }
+
+  //printf("cy_rtos_init_semaphore: %d\n", sdio_transfer_finished_semaphore);
+
+  return ret;
+}
+
+
+//uint32_t SDMMC_GetCmdResp1(SDIO_TypeDef *SDIOx, uint8_t SD_CMD, uint32_t Timeout);
+cy_rslt_t cyhal_sdio_send_cmd(const cyhal_sdio_t *obj, cyhal_transfer_t direction, cyhal_sdio_command_t command,
+                              uint32_t argument, uint32_t *response)
+
+{
+    uint32_t loop_count = 0;
+    cy_rslt_t result;
+    uint16_t attempts = 0;
+    uint32_t temp_sta;
+    if ( response != NULL )
+    {
+        *response = 0;
+    }
+    current_command = 0;
+    //platform_mcu_powersave_disable();
+
+    /* Ensure the bus isn't stuck half way through transfer */
+    //DMA2_Stream3->CR   = 0;
+    //PRINTF("power %lx\nclockcr %lx\n",SDIO->POWER,SDIO->CLKCR);
+
+restart:
+    SDIO->ICR = (uint32_t) 0xFFFFFFFF;
+    ++attempts;
+
+    /* Check if we've tried too many times */
+    if (attempts >= (uint16_t) BUS_LEVEL_MAX_RETRIES)
+    {
+        /* WWD_SDIO_RETRIES_EXCEEDED */
+        result = -1;
+        goto exit;
+    }
+
+
+    /* Send the command */
+    SDIO->ARG = argument;
+    SDIO->CMD = (uint32_t) ( command | SDIO_RESPONSE_SHORT | SDIO_WAIT_NO | SDIO_CPSM_ENABLE  );
+    loop_count = (uint32_t) COMMAND_FINISHED_CMD52_TIMEOUT_LOOPS;
+    do
+    {
+      temp_sta = SDIO->STA;
+      loop_count--;
+      if ( loop_count == 0 || (( response != NULL) && (( temp_sta & SDIO_ERROR_MASK ) != 0))  )
+      {
+        WPRINT_MACRO( ("Restart single access loop count %ld  stat %lx\n",loop_count,temp_sta) );
+        HAL_Delay(10U);
+        goto restart;
+      }
+     } while ( ( temp_sta & SDIO_FLAG_CMDACT ) != 0);
+    
+#if defined(STM32F412xG)
+        /* Errata */
+        if (command == SDIO_CMD_5)
+            SDIO->ICR = SDIO_ICR_CCRCFAILC;
+#endif
+
+    if ( response != NULL )
+    {
+        *response = SDIO->RESP1;
+    }
+    result = CY_RSLT_SUCCESS;
+
+exit:
+
+     if (result)
+     {
+       WPRINT_MACRO( ("SDIO->POWER %lx \n",SDIO->POWER) );
+       WPRINT_MACRO( ("SDIO->CLKCR %lx \n",SDIO->CLKCR) );
+       WPRINT_MACRO( ("result %lx \n", result) );
+       WPRINT_MACRO( ("cyhal_sdio_send_cmd %s\n",(result==0)? "Passed":"Failed") );
+       while(1);
+     }
+  //  platform_mcu_powersave_enable();
+#if !defined(STM32F412xG) && !defined(STM32H753xx)
+    SDIO->MASK = SDIO_MASK_SDIOITIE;
+#endif
+#if defined(STM32H753xx)
+    SDMMC1->CMD = 0;
+#endif
+
+    //PRINTF("%d %s cmd 0x%x  arg 0x%x  resp 0x%x\n",num++,(direction!=CYHAL_READ)?"Write":"Read",command,argument,(response)?*response:0);
+    return result;
+}
+
+
+
+#if defined(STM32H753xx)
+cy_rslt_t sdio_enable_high_speed(void) {
+    SDMMC_InitTypeDef sdio_init_structure;
+
+#ifdef SLOW_SDIO_CLOCK
+    sdio_init_structure.ClockDiv       = (uint8_t) 10; /* 10 = 10 MHz if SDIO clock = 200MHz */
+#else
+    sdio_init_structure.ClockDiv       = SDMMC_HSpeed_CLK_DIV;
+#endif
+    sdio_init_structure.ClockEdge      = SDMMC_CLOCK_EDGE_RISING;
+    sdio_init_structure.ClockPowerSave = SDMMC_CLOCK_POWER_SAVE_DISABLE;
+#ifndef SDIO_1_BIT
+    sdio_init_structure.BusWide        = SDMMC_BUS_WIDE_4B;
+#else
+    sdio_init_structure.BusWide        = SDMMC_BUS_WIDE_1B;
+#endif
+    sdio_init_structure.HardwareFlowControl = SDMMC_HARDWARE_FLOW_CONTROL_ENABLE;
+
+    SDMMC_Init( SDMMC1, sdio_init_structure );
+    return CY_RSLT_SUCCESS;
+}
+#else
+
+cy_rslt_t sdio_enable_high_speed(void) {
+
+  hsd.Instance = SDIO;
+  hsd.Init.ClockEdge = SDIO_CLOCK_EDGE_RISING;
+  hsd.Init.ClockBypass = SDIO_CLOCK_BYPASS_DISABLE;
+  hsd.Init.ClockPowerSave = SDIO_CLOCK_POWER_SAVE_DISABLE;
+ 
+#ifndef SDIO_1_BIT
+  hsd.Init.BusWide = SDIO_BUS_WIDE_4B;
+#else
+  hsd.Init.BusWide = SDIO_BUS_WIDE_1B;
+#endif
+  hsd.Init.HardwareFlowControl = SDIO_HARDWARE_FLOW_CONTROL_DISABLE;
+
+#ifdef SLOW_SDIO_CLOCK
+  hsd.Init.ClockDiv = 1; //30OK , 15 failed ?  48Mhz / 120 < 400 Khz
+#else
+  hsd.Init.ClockDiv = 0; //48Khz / 120 < 400 Khz
+#endif
+
+  /* Initialize SDIO peripheral interface with new configuration */
+  SDIO_Init(hsd.Instance, hsd.Init);
+  
+ /* Set Power State to ON */
+  SDIO_PowerState_ON(hsd.Instance);
+  
+    *(__IO uint32_t *) DCTRL_RWMOD_BB =  ((uint32_t)0x00000001);
+
+  /* Enable SDIO Clock */
+  __HAL_SD_ENABLE(&hsd);
+ __SDIO_DMA_ENABLE(&hsd) ;
+  return CY_RSLT_SUCCESS;
+}
+#endif
+
+static  uint32_t        find_optimal_block_size(uint32_t data_size )
+{
+    if ( data_size > (uint32_t) 256 )
+        return 512;
+    if ( data_size > (uint32_t) 128 )
+        return 256;
+    if ( data_size > (uint32_t) 64 )
+        return 128;
+    if ( data_size > (uint32_t) 32 )
+        return 64;
+    if ( data_size > (uint32_t) 16 )
+        return 32;
+    if ( data_size > (uint32_t) 8 )
+        return 16;
+    if ( data_size > (uint32_t) 4 )
+        return 8;
+    if ( data_size > (uint32_t) 2 )
+        return 4;
+
+    return 4;
+}
+
+
+
+
+static uint32_t sdio_get_blocksize(uint32_t blocksize)
+{
+  uint32_t      n=0;
+  blocksize>>=1;
+  while(blocksize)
+  {
+    n++;
+    blocksize>>=1;
+  }
+  n<<=4;
+  return n;
+}
+  uint32_t      dctrl;
+
+static void sdio_prepare_data_transfer( cyhal_transfer_t direction, uint32_t block_size, uint8_t* data, uint16_t data_size ) 
+{
+    /* Setup a single transfer using the temp buffer */
+    user_data         = data;
+    user_data_size    = data_size;
+    dma_transfer_size = (uint32_t) ( ( ( data_size + (uint16_t) block_size - 1 ) / (uint16_t) block_size ) * (uint16_t) block_size );
+
+    if ( direction == CYHAL_WRITE )
+    { 
+#if defined (STM32H753xx)
+  #if !(defined(DUAL_CORE) && defined(CORE_CM4))
+      //SCB_CleanDCache_by_Addr ((uint32_t *)data, data_size+32);
+      SCB_CleanDCache_by_Addr ((uint32_t *)dma_data_source, data_size+32);
+  #endif
+#endif
+      #ifdef MEMCPY_RX
+        memcpy(temp_dma_buffer, data, data_size);
+        dma_data_source = temp_dma_buffer;
+      #else
+        dma_data_source = data;
+      #endif
+    }
+    else
+    {
+#ifdef MEMCPY_RX
+        dma_data_source = (uint8_t*)temp_dma_buffer;
+#else
+        dma_data_source = data;
+#endif
+      //VIKR 
+      //memset(dma_data_source,0x12,data_size);
+
+#if !(defined(DUAL_CORE) && defined(CORE_CM4))
+        /* Cache-Invalidate the output from DMA */
+        //SCB_InvalidateDCache_by_Addr((uint32_t *)dma_data_source , data_size+32);
+        SCB_CleanDCache_by_Addr ((uint32_t *)dma_data_source, data_size+32);
+#endif
+    }
+
+    SDIO->DTIMER = (uint32_t) 0xFFFFFFFF;
+    SDIO->DLEN   = dma_transfer_size;
+#if defined (STM32H753xx)
+    dctrl= sdio_get_blocksize(block_size) | ((direction==CYHAL_READ)? SDIO_TRANSFER_DIR_TO_SDIO:SDIO_TRANSFER_DIR_TO_CARD) | SDIO_TRANSFER_MODE_BLOCK | SDIO_DPSM_DISABLE  | SDIO_DCTRL_SDIOEN;
+    SDIO->DCTRL = dctrl;
+#else
+    SDIO->DCTRL  = sdio_get_blocksize(block_size) | ((direction==CYHAL_READ)? SDIO_TRANSFER_DIR_TO_SDIO:SDIO_TRANSFER_DIR_TO_CARD) | SDIO_TRANSFER_MODE_BLOCK | SDIO_DPSM_ENABLE | SDIO_DCTRL_DTMODE_1 | SDIO_DCTRL_SDIOEN;    
+#endif
+    
+#if defined (STM32H753xx)
+    SDMMC1->IDMACTRL  = SDMMC_ENABLE_IDMA_SINGLE_BUFF;
+    SDMMC1->IDMABASE0 = (uint32_t) dma_data_source;
+#else
+    /* DMA2 Stream3 */
+    DMA2_Stream3->CR   = 0;
+    DMA2->LIFCR        = (uint32_t) ( 0x3F << 22 );
+    DMA2_Stream3->FCR  = (uint32_t) ( 0x00000021 | DMA_FIFOMODE_ENABLE | DMA_FIFO_THRESHOLD_FULL );
+    DMA2_Stream3->PAR  = (uint32_t) &SDIO->FIFO;
+    DMA2_Stream3->M0AR = (uint32_t) dma_data_source;
+    DMA2_Stream3->NDTR = dma_transfer_size/4;
+#endif
+}
+
+
+void sdio_enable_bus_irq( void )
+{
+#if defined(STM32F412xG)
+    SDIO->MASK = SDIO_MASK_CMDRENDIE | SDIO_MASK_CMDSENTIE;
+#elif defined (STM32H753xx)
+    SDMMC1->MASK = SDMMC_IT_RXOVERR | SDMMC_IT_TXUNDERR | SDMMC_IT_DATAEND | SDMMC_IT_CMDREND | SDMMC_IT_CMDSENT;
+#else
+    SDIO->MASK = SDIO_MASK_SDIOITIE | SDIO_MASK_CMDRENDIE | SDIO_MASK_CMDSENTIE;
+#endif
+
+}
+
+static volatile bool sdio_transfer_finished_var;
+
+cy_rslt_t cyhal_sdio_bulk_transfer(cyhal_sdio_t *obj, cyhal_transfer_t direction, uint32_t argument,
+                                   const uint32_t *data, uint16_t length, uint32_t *response)
+
+{
+    cy_rslt_t result;
+ 
+    uint32_t loop_count = 0;
+    uint16_t attempts = 0;
+    uint32_t  block_size=64;
+    sdio_cmd_argument_t arg;
+    uint32_t      cmd;
+    current_command = SDIO_CMD_53;
+    current_transfer_direction = direction;
+    arg.value = argument;
+    sdio_enable_bus_irq();
+    if ( response != NULL )
+    {
+        *response = 0;
+    }
+
+    /* Ensure the bus isn't stuck half way through transfer */
+    // DMA2_Stream3->CR   = 0;
+
+restart:
+
+    sdio_transfer_failed=0;
+    SDMMC1->ICR = (uint32_t) 0xFFFFFFFF;
+    ++attempts;
+
+    /* Check if we've tried too many times */
+    if (attempts >= (uint16_t) BUS_LEVEL_MAX_RETRIES)
+    {
+        /* WWD_SDIO_RETRIES_EXCEEDED */
+        WPRINT_MACRO(("Too much attempt\n"));
+        result = -1;
+        goto exit;
+    }
+
+    /* Dodgy STM32 hack to set the CMD53 byte mode size to be the same as the block size */
+    if ( arg.cmd53.block_mode == 0 )
+    {
+      block_size = find_optimal_block_size( arg.cmd53.count );
+      if ( block_size < SDIO_512B_BLOCK )
+      {
+        arg.cmd53.count = block_size;
+      }
+      else
+      {
+        arg.cmd53.count = 0;
+      }
+      argument = arg.value;
+    }
+
+    SDMMC1->CMD |= SDMMC_CMD_CMDTRANS;
+    
+    /* Prepare the SDIO for a data transfer */
+    sdio_prepare_data_transfer( direction, block_size, (uint8_t*) data, (uint32_t) length );
+
+    sdio_transfer_finished_var = false;
+
+    /* Send the command */
+    //PRINTF("%d bs=%d argument=%x\n",num++,block_size,argument);
+    SDMMC1->ARG = argument;
+    cmd = (uint32_t) ( SDIO_CMD_53 | SDMMC_RESPONSE_SHORT | SDMMC_WAIT_NO | SDMMC_CPSM_ENABLE | SDMMC_CMD_CMDTRANS );
+    SDMMC1->CMD = cmd;
+    /* Wait for the whole transfer to complete */
+
+    //printf("cy_rtos_get_semaphore: %d\n", sdio_transfer_finished_semaphore);
+
+#if 0
+    uint32_t start = HAL_GetTick();
+    result = CY_RSLT_SUCCESS;
+    while (sdio_transfer_finished_var == false && ((HAL_GetTick() - start) < 50)) {
+
+    }
+    if ((HAL_GetTick() - start) >= 50) {
+      result = -1;
+    }
+#else
+    result = cy_rtos_get_semaphore(&sdio_transfer_finished_semaphore, 50, WHD_FALSE);
+#endif
+    if ( result != CY_RSLT_SUCCESS )
+    {
+      WPRINT_MACRO(("failed getting semaphore\n"));
+      goto exit;
+    }
+    if ( sdio_transfer_failed  )
+    {
+      WPRINT_MACRO( ("try again sdio_transfer_failed  %x irq %x\n",sdio_transfer_failed,irqstatus) );
+      goto restart;
+    }
+    /* Check if there were any SDIO errors */
+    if ( ( SDIO->STA & ( SDIO_STA_DTIMEOUT | SDIO_STA_CTIMEOUT ) ) != 0 )
+    {
+      WPRINT_MACRO(("sdio errors SDIO_STA_DTIMEOUT | SDIO_STA_CTIMEOUT\n"));
+      goto restart;
+    }
+    else if ( ( ( SDIO->STA & ( SDIO_STA_CCRCFAIL | SDIO_STA_DCRCFAIL | SDIO_STA_TXUNDERR | SDIO_STA_RXOVERR ) ) != 0 ) )
+    {
+      WPRINT_MACRO(("sdio errors SDIO_STA_CCRCFAIL | SDIO_STA_DCRCFAIL | SDIO_STA_TXUNDERR | SDIO_STA_RXOVER \n"));
+      goto restart;
+    }
+
+#if 0
+    /* Wait till complete */
+    loop_count = (uint32_t) SDIO_TX_RX_COMPLETE_TIMEOUT_LOOPS*1000;
+    do
+    {
+      loop_count--;
+      if ( loop_count == 0 || ( ( SDIO->STA & SDIO_ERROR_MASK ) != 0 ) )
+      {
+        PRINTF("sdio errors SDIO->STA & SDIO_ERROR_MASK or TO  , loopct=%d \n",loop_count);
+        goto restart;
+      }
+    } while ( ( SDIO->STA & ( SDIO_STA_TXACT | SDIO_STA_RXACT ) ) != 0 );
+#endif
+
+#ifdef MEMCPY_RX
+    if ( direction == CYHAL_READ )
+    {
+      memcpy( user_data, dma_data_source, (size_t) user_data_size );
+    }
+#endif
+ 
+  if ( response != NULL )
+  {
+    *response = SDIO->RESP1;
+  }
+  result = CY_RSLT_SUCCESS;
+
+exit:
+#if !defined(STM32F412xG) && !defined(STM32H753xx)
+    SDIO->MASK = SDIO_MASK_SDIOITIE;
+#endif
+
+#if defined(STM32H753xx)
+    SDMMC1->CMD = 0;
+#endif
+
+  //HAL_Delay(30);
+  if (0) { //(direction==CYHAL_READ) {
+    WPRINT_MACRO(("%d %s cmd 53 argument %lx datasize %d  blocknumber 0x%x   cmdis %lx %lu dctrl = %x\n",num++,(direction!=CYHAL_READ)?"Write":"Read",argument,length,arg.cmd53.count,cmd,cmd,dctrl));
+  }
+  return result;
+}
+
+
+void cyhal_sdio_register_irq(cyhal_sdio_t *obj, cyhal_sdio_irq_handler_t handler, void *handler_arg)
+{
+  whd_handler = (whd_driver_t)handler_arg;
+  sdio_irq_handler = handler;
+}
+
+void cyhal_sdio_irq_enable(cyhal_sdio_t *obj, cyhal_sdio_irq_event_t event, bool enable)
+{
+
+}
+
+#if defined (STM32H753xx)
+void SDMMC1_IRQHandler(void )
+{
+    uint32_t intstatus = SDIO->STA;
+  //  WWD_BUS_STATS_INCREMENT_VARIABLE( sdio_intrs );
+
+    irqstatus = intstatus;
+//VIKR  | SDIO_STA_STBITERR )
+   if ( ( intstatus & ( SDIO_STA_CCRCFAIL | SDIO_STA_DCRCFAIL | SDIO_STA_TXUNDERR | SDIO_STA_RXOVERR )) != 0 )
+    {
+        //WWD_BUS_STATS_INCREMENT_VARIABLE( error_intrs );
+        //printf("sdio error flagged\n");
+        sdio_transfer_failed = intstatus;
+        SDIO->ICR = (uint32_t) 0xffffffff;
+        cy_rtos_set_semaphore(&sdio_transfer_finished_semaphore, WHD_TRUE);
+        //sdio_transfer_finished_var = true;
+    }
+    else
+    {
+        if ((intstatus & (SDMMC_STA_CMDREND | SDMMC_STA_CMDSENT)) != 0)
+        {
+            if ( ( SDMMC1->RESP1 & 0x800 ) != 0 )
+            {
+                sdio_transfer_failed = irqstatus;
+                //sdio_transfer_finished_var = true;
+                cy_rtos_set_semaphore(&sdio_transfer_finished_semaphore, WHD_TRUE);
+            }
+
+            /* Clear all command/response interrupts */
+            SDMMC1->ICR = (SDMMC_STA_CMDREND | SDMMC_STA_CMDSENT);
+        }
+
+        /* Check whether the external interrupt was triggered */
+        if (intstatus & SDMMC_STA_SDIOIT)
+        {
+            /* Clear the interrupt */
+            SDMMC1->ICR = SDMMC_STA_SDIOIT;
+            /* Mask interrupt, to be unmasked later by WICED WWD thread */
+            //SDMMC1->MASK &= ~(SDMMC_MASK_SDIOITIE);//VIKR (SDMMC_ICR_SDIOITC);
+            /* Inform WICED WWD thread */
+            // whd_thread_notify_irq(whd_handler);
+            sdio_irq_handler(whd_handler, CYHAL_SDIO_CARD_INTERRUPT);
+            //cy_rtos_set_semaphore(&sdio_transfer_finished_semaphore, WHD_TRUE);
+        }
+
+        if (intstatus & SDMMC_STA_DATAEND)
+        {
+            SDMMC1->ICR      = SDMMC_STA_DATAEND;
+            SDMMC1->DLEN     = 0;
+            SDMMC1->DCTRL    = SDMMC_DCTRL_SDIOEN;
+            SDMMC1->IDMACTRL = SDMMC_DISABLE_IDMA;
+            SDMMC1->CMD      = 0;
+            //sdio_transfer_finished_var = true;
+            cy_rtos_set_semaphore(&sdio_transfer_finished_semaphore, WHD_TRUE);
+        }
+    }
+}
+#else
+void sdio_irq(void )
+{
+    uint32_t intstatus = SDIO->STA;
+  //  WWD_BUS_STATS_INCREMENT_VARIABLE( sdio_intrs );
+#if defined(STM32F412xG)
+    if (current_command == SDIO_CMD_5)
+        SDIO->ICR = SDIO_ICR_CCRCFAILC;
+#endif
+
+    irqstatus = intstatus;
+
+   if ( ( intstatus & ( SDIO_STA_CCRCFAIL | SDIO_STA_DCRCFAIL | SDIO_STA_TXUNDERR | SDIO_STA_RXOVERR  | SDIO_STA_STBITERR )) != 0 )
+    {
+        //WWD_BUS_STATS_INCREMENT_VARIABLE( error_intrs );
+        //wiced_assert("sdio error flagged",0);
+        sdio_transfer_failed = intstatus;
+        SDIO->ICR = (uint32_t) 0xffffffff;
+        cy_rtos_set_semaphore(&sdio_transfer_finished_semaphore, WHD_TRUE);
+    }
+    else
+    {
+        if ((intstatus & (SDIO_STA_CMDREND | SDIO_STA_CMDSENT)) != 0)
+        {
+            if ( ( SDIO->RESP1 & 0x800 ) != 0 )
+            {
+                sdio_transfer_failed = irqstatus;
+                cy_rtos_set_semaphore(&sdio_transfer_finished_semaphore, WHD_TRUE);
+            }
+            else if (current_command == SDIO_CMD_53)
+            {
+                if (current_transfer_direction == CYHAL_WRITE)
+                {
+                    DMA2_Stream3->CR = DMA_MEMORY_TO_PERIPH |
+                                       DMA_CHANNEL_4 | DMA_PINC_DISABLE | DMA_MINC_ENABLE |
+                                       DMA_PDATAALIGN_WORD | DMA_MDATAALIGN_WORD |
+                                       DMA_NORMAL | DMA_PRIORITY_VERY_HIGH |
+                                       DMA_MBURST_INC4 | DMA_PBURST_INC4 | DMA_SxCR_PFCTRL | DMA_SxCR_EN | DMA_SxCR_TCIE;
+                }
+                else
+                {
+                    DMA2_Stream3->CR = DMA_PERIPH_TO_MEMORY |
+                                       DMA_CHANNEL_4 | DMA_PINC_DISABLE | DMA_MINC_ENABLE |
+                                       DMA_PDATAALIGN_WORD | DMA_MDATAALIGN_WORD |
+                                       DMA_NORMAL | DMA_PRIORITY_VERY_HIGH |
+                                       DMA_MBURST_INC4 | DMA_PBURST_INC4 | DMA_SxCR_PFCTRL | DMA_SxCR_EN | DMA_SxCR_TCIE;
+                }
+            }
+
+            /* Clear all command/response interrupts */
+            SDIO->ICR = (SDIO_STA_CMDREND | SDIO_STA_CMDSENT);
+        }
+
+        /* Check whether the external interrupt was triggered */
+        if ( ( intstatus & SDIO_STA_SDIOIT ) != 0 )
+        {
+            /* Clear the interrupt and then inform WICED thread */
+            SDIO->ICR = SDIO_ICR_SDIOITC;
+            whd_thread_notify_irq(whd_handler);
+        }
+    }
+}
+#endif
+
+void  sdio_dma_irq(void)
+{
+    /* Clear interrupt */
+    DMA2->LIFCR = (uint32_t) (0x3F << 22);
+    cy_rtos_set_semaphore(&sdio_transfer_finished_semaphore, WHD_TRUE);
+}
diff --git a/targets/TARGET_STM/TARGET_STM32H7/TARGET_STM32H747xI/TARGET_PORTENTA_H7/COMPONENT_WHD/interface/cyhal_sdio.h b/targets/TARGET_STM/TARGET_STM32H7/TARGET_STM32H747xI/TARGET_PORTENTA_H7/COMPONENT_WHD/interface/cyhal_sdio.h
new file mode 100644
index 0000000000..7e07a1ed72
--- /dev/null
+++ b/targets/TARGET_STM/TARGET_STM32H7/TARGET_STM32H747xI/TARGET_PORTENTA_H7/COMPONENT_WHD/interface/cyhal_sdio.h
@@ -0,0 +1,274 @@
+/***************************************************************************//**
+* \file cyhal_sdio.h
+*
+* \brief
+* Provides a high level interface for interacting with the Cypress SDIO interface.
+* This interface abstracts out the chip specific details. If any chip specific
+* functionality is necessary, or performance is critical the low level functions
+* can be used directly.
+*
+********************************************************************************
+* \copyright
+* Copyright 2018-2019 Cypress Semiconductor Corporation
+* SPDX-License-Identifier: Apache-2.0
+*
+* Licensed under the Apache License, Version 2.0 (the "License");
+* you may not use this file except in compliance with the License.
+* You may obtain a copy of the License at
+*
+*     http://www.apache.org/licenses/LICENSE-2.0
+*
+* Unless required by applicable law or agreed to in writing, software
+* distributed under the License is distributed on an "AS IS" BASIS,
+* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+* See the License for the specific language governing permissions and
+* limitations under the License.
+*******************************************************************************/
+
+/**
+ * \addtogroup group_hal_sdio SDIO (Secure Digital Input Output)
+ * \ingroup group_hal
+ * \{
+ * High level interface for interacting with the Cypress SDIO interface.
+ *
+ * \defgroup group_hal_sdio_macros Macros
+ * \defgroup group_hal_sdio_functions Functions
+ * \defgroup group_hal_sdio_data_structures Data Structures
+ * \defgroup group_hal_sdio_enums Enumerated Types
+ */
+
+#pragma once
+
+#include <stdint.h>
+#include <stdbool.h>
+#include "cy_result.h"
+#include "cyhal_hw_types.h"
+#include "cyhal_modules.h"
+
+#if defined(__cplusplus)
+extern "C" {
+#endif
+
+
+/**
+ * \addtogroup group_hal_sdio_macros
+ * \{
+ */
+
+#define CYHAL_SDIO_RET_NO_ERRORS           (0x00)     /**< No error*/
+#define CYHAL_SDIO_RET_NO_SP_ERRORS        (0x01)     /**< Non-specific error code*/
+#define CYHAL_SDIO_RET_CMD_CRC_ERROR       (0x02)     /**< There was a CRC error on the Command/Response*/
+#define CYHAL_SDIO_RET_CMD_IDX_ERROR       (0x04)     /**< The index for the command didn't match*/
+#define CYHAL_SDIO_RET_CMD_EB_ERROR        (0x08)     /**< There was an end bit error on the command*/
+#define CYHAL_SDIO_RET_DAT_CRC_ERROR       (0x10)     /**< There was a data CRC Error*/
+#define CYHAL_SDIO_RET_CMD_TIMEOUT         (0x20)     /**< The command didn't finish before the timeout period was over*/
+#define CYHAL_SDIO_RET_DAT_TIMEOUT         (0x40)     /**< The data didn't finish before the timeout period was over*/
+#define CYHAL_SDIO_RET_RESP_FLAG_ERROR     (0x80)      /**< There was an error in the resposne flag for command 53*/
+
+#define CYHAL_SDIO_CLOCK_ERROR          (0x100)   /**< Failed to initial clock for SDIO */
+#define CYHAL_SDIO_BAD_ARGUMENT         (0x200)   /**< Bad argument passed for SDIO */
+#define CYHAL_SDIO_SEMA_NOT_INITED      (0x400)   /**< Semaphore is not initiated */
+#define CYHAL_SDIO_FUNC_NOT_SUPPORTED   (0x800)   /**< Function is not supported */
+
+/* HAL return value defines */
+
+/** Incorrect parameter value define */
+#define CYHAL_SDIO_RSLT_ERR_BAD_PARAM          CY_RSLT_CREATE(CY_RSLT_TYPE_ERROR, \
+                                                              CYHAL_RSLT_MODULE_SDIO, \
+                                                              CYHAL_SDIO_BAD_ARGUMENT)
+
+/** Clock initialization error define */
+#define CYHAL_SDIO_RSLT_ERR_CLOCK             CY_RSLT_CREATE(CY_RSLT_TYPE_ERROR, \
+                                                             CYHAL_RSLT_MODULE_SDIO, \
+                                                             CYHAL_SDIO_CLOCK_ERROR)
+
+/** Semaphore not initiated error define */
+#define CYHAL_SDIO_RSLT_ERR_SEMA_NOT_INITED   CY_RSLT_CREATE(CY_RSLT_TYPE_ERROR, \
+                                                             CYHAL_RSLT_MODULE_SDIO, \
+                                                             CYHAL_SDIO_SEMA_NOT_INITED)
+
+/** Error define based on SDIO lower function return value */
+#define CYHAL_SDIO_RSLT_ERR_FUNC_RET(retVal)  CY_RSLT_CREATE(CY_RSLT_TYPE_ERROR, \
+                                                             CYHAL_RSLT_MODULE_SDIO, (retVal) )
+
+/** \} group_hal_sdio_macros */
+
+
+/**
+ * \addtogroup group_hal_sdio_enums
+ * \{
+ */
+
+/** Commands that can be issued */
+typedef enum
+{
+    CYHAL_SDIO_CMD_GO_IDLE_STATE  =  0, //!> Go to idle state
+    CYHAL_SDIO_CMD_SEND_RELATIVE_ADDR  =  3, //!> Send a relative address
+    CYHAL_SDIO_CMD_IO_SEND_OP_COND  =  5, //!> Send an OP IO
+    CYHAL_SDIO_CMD_SELECT_CARD  =  7, //!> Send a card select
+    CYHAL_SDIO_CMD_GO_INACTIVE_STATE = 15, //!> Go to inactive state
+    CYHAL_SDIO_CMD_IO_RW_DIRECT = 52, //!> Perform a direct read/write
+    CYHAL_SDIO_CMD_IO_RW_EXTENDED = 53, //!> Perform an extended read/write
+} cyhal_sdio_command_t;
+
+/** Types of transfer that can be performed */
+typedef enum
+{
+    CYHAL_READ, //!> Read from the card
+    CYHAL_WRITE //!> Write to the card
+} cyhal_transfer_t;
+
+/** Events that can cause an SDIO interrupt */
+typedef enum
+{
+    CYHAL_SDIO_CMD_COMPLETE   = 0x0001, //!> Command Complete
+    CYHAL_SDIO_XFER_COMPLETE  = 0x0002, //!> Host read/write transfer is complete
+    CYHAL_SDIO_BGAP_EVENT     = 0x0004, //!> This bit is set when both read/write transaction is stopped
+    CYHAL_SDIO_DMA_INTERRUPT  = 0x0008, //!> Host controller detects an SDMA Buffer Boundary during transfer
+    CYHAL_SDIO_BUF_WR_READY   = 0x0010, //!> This bit is set if the Buffer Write Enable changes from 0 to 1
+    CYHAL_SDIO_BUF_RD_READY   = 0x0020, //!> This bit is set if the Buffer Read Enable changes from 0 to 1
+    CYHAL_SDIO_CARD_INSERTION = 0x0040, //!> This bit is set if the Card Inserted in the Present State
+    CYHAL_SDIO_CARD_REMOVAL   = 0x0080, //!> This bit is set if the Card Inserted in the Present State
+    CYHAL_SDIO_CARD_INTERRUPT = 0x0100, //!> The synchronized value of the DAT[1] interrupt input for SD mode
+    CYHAL_SDIO_INT_A          = 0x0200, //!> Reserved: set to 0
+    CYHAL_SDIO_INT_B          = 0x0400, //!> Reserved: set to 0
+    CYHAL_SDIO_INT_C          = 0x0800, //!> Reserved: set to 0,
+    CYHAL_SDIO_RE_TUNE_EVENT  = 0x1000, //!> Reserved: set to 0,
+    CYHAL_SDIO_FX_EVENT       = 0x2000, //!> This status is set when R[14] of response register is set to 1
+    CYHAL_SDIO_CQE_EVENT      = 0x4000, //!> This status is set if Command Queuing/Crypto event has occurred
+    CYHAL_SDIO_ERR_INTERRUPT  = 0x8000, //!> If any of the bits in the Error Interrupt Status register are set
+    CYHAL_SDIO_ALL_INTERRUPTS = 0xE1FF, //!> Is used to enable/disable all interrupts
+} cyhal_sdio_irq_event_t;
+
+/** \} group_hal_sdio_enums */
+
+
+/**
+ * \addtogroup group_hal_sdio_data_structures
+ * \{
+ */
+
+/** SDIO controller initial configuration */
+typedef struct
+{
+    uint32_t frequencyhal_hz; //!< Clock frequency, in hertz
+    uint16_t block_size; //!< Block size
+} cyhal_sdio_cfg_t;
+
+/** Handler for SDIO interrupts */
+typedef void (*cyhal_sdio_irq_handler_t)(void *handler_arg, cyhal_sdio_irq_event_t event);
+
+/** \} group_hal_sdio_data_structures */
+
+
+/**
+ * \addtogroup group_hal_sdio_functions
+ * \{
+ */
+
+/** Initialize the SDIO peripheral
+ *
+ * @param[out] obj               The SDIO object
+ * @param[out] clk               The pin connected to the clk signal
+ * @param[in]  cmd               The pin connected to the command signal
+ * @param[in]  data0             The pin connected to the data0 signal
+ * @param[in]  data1             The pin connected to the data1 signal
+ * @param[in]  data2             The pin connected to the data2 signal
+ * @param[in]  data3             The pin connected to the data3 signal
+ * @return The status of the init request
+ */
+cy_rslt_t cyhal_sdio_init(cyhal_sdio_t *obj, cyhal_gpio_t cmd, cyhal_gpio_t clk, cyhal_gpio_t data0, cyhal_gpio_t data1,
+                          cyhal_gpio_t data2, cyhal_gpio_t data3);
+
+/** Release the SDIO peripheral, not currently invoked. It requires further
+ *  resource management.
+ *
+ * @param[in,out] obj The SDIO object
+ */
+void cyhal_sdio_free(cyhal_sdio_t *obj);
+
+/** Configure the SDIO block.
+ *
+ * @param[in,out] obj    The SDIO object
+ * @param[in]     config The sdio configuration to apply
+ * @return The status of the configure request
+ */
+cy_rslt_t cyhal_sdio_configure(cyhal_sdio_t *obj, const cyhal_sdio_cfg_t *config);
+
+/** Sends a command to the SDIO block.
+ *
+ * @param[in,out] obj       The SDIO object
+ * @param[in]     direction The direction of transfer (read/write)
+ * @param[in]     command   The SDIO command to send
+ * @param[in]     argument  The argument to the command
+ * @param[out]    response  The response from the SDIO device
+ * @return The status of the configure request
+ */
+cy_rslt_t cyhal_sdio_send_cmd(const cyhal_sdio_t *obj, cyhal_transfer_t direction, cyhal_sdio_command_t command,
+                              uint32_t argument, uint32_t *response);
+
+/** Performs a bulk data transfer (CMD=53) to the SDIO block.
+ *
+ * @param[in,out] obj       The SDIO object
+ * @param[in]     direction The direction of transfer (read/write)
+ * @param[in]     argument  The argument to the command
+ * @param[in]     data      The data to send to the SDIO device. The data buffer
+ *                          should be aligned to the block size (64 bytes) if data
+ *                          size is greater that block size (64 bytes).
+ * @param[in]     length    The number of bytes to send
+ * @param[out]    response  The response from the SDIO device
+ * @return The status of the configure request
+ */
+cy_rslt_t cyhal_sdio_bulk_transfer(cyhal_sdio_t *obj, cyhal_transfer_t direction, uint32_t argument,
+                                   const uint32_t *data, uint16_t length, uint32_t *response);
+
+/** Performs a bulk asynchronus data transfer (CMD=53) to the SDIO block.
+ *
+ * @param[in,out] obj       The SDIO object
+ * @param[in]     direction The direction of transfer (read/write)
+ * @param[in]     argument  The argument to the command
+ * @param[in]     data      The data to send to the SDIO device
+ * @param[in]     length    The number of bytes to send
+ * @return The status of the configure request
+ */
+cy_rslt_t cyhal_sdio_transfer_async(cyhal_sdio_t *obj, cyhal_transfer_t direction, uint32_t argument,
+                                    const uint32_t *data, uint16_t length);
+
+/** Checks if the specified SDIO is in use
+ *
+ * @param[in]  obj  The SDIO peripheral to check
+ * @return Indication of whether the SDIO is still transmitting
+ */
+bool cyhal_sdio_is_busy(const cyhal_sdio_t *obj);
+
+/** Abort an SDIO transfer
+ *
+ * @param[in] obj The SDIO peripheral to stop
+ * @return The status of the abort_async request
+ */
+cy_rslt_t cyhal_sdio_abort_async(const cyhal_sdio_t *obj);
+
+/** The sdio interrupt handler registration
+ *
+ * @param[in] obj         The SDIO object
+ * @param[in] handler     The callback handler which will be invoked when the interrupt fires
+ * @param[in] handler_arg Generic argument that will be provided to the handler when called
+ */
+void cyhal_sdio_register_irq(cyhal_sdio_t *obj, cyhal_sdio_irq_handler_t handler, void *handler_arg);
+
+/** Configure sdio interrupt.
+ *
+ * @param[in] obj      The SDIO object
+ * @param[in] event    The sdio IRQ type
+ * @param[in] enable   Set to non-zero to enable events, or zero to disable them
+ */
+void cyhal_sdio_irq_enable(cyhal_sdio_t *obj, cyhal_sdio_irq_event_t event, bool enable);
+
+/** \} group_hal_sdio_functions */
+
+#if defined(__cplusplus)
+}
+#endif
+
+/** \} group_hal_sdio */
+
diff --git a/targets/TARGET_STM/TARGET_STM32H7/TARGET_STM32H747xI/TARGET_PORTENTA_H7/COMPONENT_WHD/interface/cyhal_spi.h b/targets/TARGET_STM/TARGET_STM32H7/TARGET_STM32H747xI/TARGET_PORTENTA_H7/COMPONENT_WHD/interface/cyhal_spi.h
new file mode 100644
index 0000000000..345f3bd86a
--- /dev/null
+++ b/targets/TARGET_STM/TARGET_STM32H7/TARGET_STM32H747xI/TARGET_PORTENTA_H7/COMPONENT_WHD/interface/cyhal_spi.h
@@ -0,0 +1,250 @@
+/***************************************************************************//**
+* \file cyhal_spi.h
+*
+* \brief
+* Provides a high level interface for interacting with the Cypress SPI.
+* This interface abstracts out the chip specific details. If any chip specific
+* functionality is necessary, or performance is critical the low level functions
+* can be used directly.
+*
+********************************************************************************
+* \copyright
+* Copyright 2018-2019 Cypress Semiconductor Corporation
+* SPDX-License-Identifier: Apache-2.0
+*
+* Licensed under the Apache License, Version 2.0 (the "License");
+* you may not use this file except in compliance with the License.
+* You may obtain a copy of the License at
+*
+*     http://www.apache.org/licenses/LICENSE-2.0
+*
+* Unless required by applicable law or agreed to in writing, software
+* distributed under the License is distributed on an "AS IS" BASIS,
+* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+* See the License for the specific language governing permissions and
+* limitations under the License.
+*******************************************************************************/
+
+/**
+ * \addtogroup group_hal_spi SPI (Serial Peripheral Interface)
+ * \ingroup group_hal
+ * \{
+ * High level interface for interacting with the Cypress SPI.
+ *
+ * \defgroup group_hal_spi_macros Macros
+ * \defgroup group_hal_spi_functions Functions
+ * \defgroup group_hal_spi_data_structures Data Structures
+ * \defgroup group_hal_spi_enums Enumerated Types
+ */
+
+#pragma once
+
+#include <stdint.h>
+#include <stdbool.h>
+#include "cy_result.h"
+#include "cyhal_hw_types.h"
+#include "cyhal_modules.h"
+
+#if defined(__cplusplus)
+extern "C" {
+#endif
+
+
+/**
+ * \addtogroup group_hal_spi_macros
+ * \{
+ */
+
+/** Bad argument */
+#define CYHAL_SPI_RSLT_BAD_ARGUMENT                    (CY_RSLT_CREATE(CY_RSLT_TYPE_ERROR, CYHAL_RSLT_MODULE_SPI, 0) )
+/** Failed to initialize SPI clock */
+#define CYHAL_SPI_RSLT_CLOCK_ERROR                     (CY_RSLT_CREATE(CY_RSLT_TYPE_ERROR, CYHAL_RSLT_MODULE_SPI, 1) )
+/** Failed to Transfer SPI data */
+#define CYHAL_SPI_RSLT_TRANSFER_ERROR                  (CY_RSLT_CREATE(CY_RSLT_TYPE_ERROR, CYHAL_RSLT_MODULE_SPI, 2) )
+/** Provided clock is not supported by SPI */
+#define CYHAL_SPI_RSLT_CLOCK_NOT_SUPPORTED             (CY_RSLT_CREATE(CY_RSLT_TYPE_ERROR, CYHAL_RSLT_MODULE_SPI, 3) )
+/** Provided PIN configuration is not supported by SPI */
+#define CYHAL_SPI_RSLT_PIN_CONFIG_NOT_SUPPORTED        (CY_RSLT_CREATE(CY_RSLT_TYPE_ERROR, CYHAL_RSLT_MODULE_SPI, 5) )
+/** Provided PIN configuration is not supported by SPI */
+#define CYHAL_SPI_RSLT_INVALID_PIN_API_NOT_SUPPORTED   (CY_RSLT_CREATE(CY_RSLT_TYPE_ERROR, CYHAL_RSLT_MODULE_SPI, 6) )
+/** The requested resource type is invalid */
+#define CYHAL_SPI_RSLT_ERR_INVALID_PIN                 (CY_RSLT_CREATE(CY_RSLT_TYPE_ERROR, CYHAL_RSLT_MODULE_SPI, 7) )
+
+/** \} group_hal_spi_macros */
+
+
+/** SPI interrupt triggers */
+typedef enum
+{
+    CYHAL_SPI_IRQ_NONE                = 0,      //!< Disable all interrupt call backs
+    /** All transfer data has been moved into data FIFO */
+    CYHAL_SPI_IRQ_DATA_IN_FIFO        = 1 << 1,
+    /** Transfer complete. */
+    CYHAL_SPI_IRQ_DONE                = 1 << 2,
+    /** An error occurred while transferring data */
+    CYHAL_SPI_IRQ_ERROR               = 1 << 3,
+} cyhal_spi_irq_event_t;
+
+/** Handler for SPI interrupts */
+typedef void (*cyhal_spi_irq_handler_t)(void *handler_arg, cyhal_spi_irq_event_t event);
+
+/** SPI operating modes */
+typedef enum
+{
+    /** Standard motorola SPI CPOL=0, CPHA=0 with MSB first operation */
+    CYHAL_SPI_MODE_00_MSB,
+    /** Standard motorola SPI CPOL=0, CPHA=0 with LSB first operation */
+    CYHAL_SPI_MODE_00_LSB,
+    /** Standard motorola SPI CPOL=0, CPHA=1 with MSB first operation */
+    CYHAL_SPI_MODE_01_MSB,
+    /** Standard motorola SPI CPOL=0, CPHA=1 with LSB first operation */
+    CYHAL_SPI_MODE_01_LSB,
+    /** Standard motorola SPI CPOL=1, CPHA=0 with MSB first operation */
+    CYHAL_SPI_MODE_10_MSB,
+    /** Standard motorola SPI CPOL=1, CPHA=0 with LSB first operation */
+    CYHAL_SPI_MODE_10_LSB,
+    /** Standard motorola SPI CPOL=1, CPHA=1 with MSB first operation */
+    CYHAL_SPI_MODE_11_MSB,
+    /** Standard motorola SPI CPOL=1, CPHA=1 with LSB first operation */
+    CYHAL_SPI_MODE_11_LSB,
+} cyhal_spi_mode_t;
+
+/** Initial SPI configuration. */
+typedef struct
+{
+    cyhal_spi_mode_t mode; //!< The operating mode
+    uint8_t data_bits; //!< The number of bits per transfer
+    bool is_slave; //!< Whether the peripheral is operating as slave or master
+} cyhal_spi_cfg_t;
+
+
+/** Initialize the SPI peripheral
+ *
+ * Configures the pins used by SPI, sets a default format and frequency, and enables the peripheral
+ * @param[out] obj  The SPI object to initialize
+ * @param[in]  mosi The pin to use for MOSI
+ * @note At least MOSI or MISO pin should be non-NC
+ * @param[in]  miso The pin to use for MISO
+ * @note At least MOSI or MISO pin should be non-NC
+ * @param[in]  sclk The pin to use for SCLK
+ * @note This pin cannot be NC
+ * @param[in]  ssel The pin to use for SSEL
+ * @note This pin can be NC
+ * @param[in]  clk The clock to use can be shared, if not provided a new clock will be allocated
+ * @param[in]  bits      The number of bits per frame
+ * @note bits should be 8 or 16
+ * @param[in]  mode      The SPI mode (clock polarity, phase, and shift direction)
+ * @param[in]  is_slave  false for master mode or true for slave mode operation
+ * @return The status of the init request
+ */
+cy_rslt_t cyhal_spi_init(cyhal_spi_t *obj, cyhal_gpio_t mosi, cyhal_gpio_t miso, cyhal_gpio_t sclk, cyhal_gpio_t ssel,
+                         const cyhal_clock_divider_t *clk,
+                         uint8_t bits, cyhal_spi_mode_t mode, bool is_slave);
+
+/** Release a SPI object
+ *
+ * Return the peripheral, pins and clock owned by the SPI object to their reset state
+ * @param[in,out] obj The SPI object to deinitialize
+ */
+void cyhal_spi_free(cyhal_spi_t *obj);
+
+/** Set the SPI baud rate
+ *
+ * Actual frequency may differ from the desired frequency due to available dividers and bus clock
+ * Configures the SPI peripheral's baud rate
+ * @param[in,out] obj The SPI object to configure
+ * @param[in]     hz  The baud rate in Hz
+ * @return The status of the frequency request
+ */
+cy_rslt_t cyhal_spi_frequency(cyhal_spi_t *obj, uint32_t hz);
+
+/** Get a received value out of the SPI receive buffer
+ *
+ * Blocks until a value is available
+ * @param[in] obj   The SPI peripheral to read
+ * @param[in] value The value received
+ * @return The status of the read request
+ * @note
+ * - In Master mode, MISO pin required to be non-NC for this API to operate
+ * - In Slave mode, MOSI pin required to be non-NC for this API to operate
+ */
+cy_rslt_t cyhal_spi_read(cyhal_spi_t *obj, uint32_t *value);
+
+/** Write a byte out
+ *
+ * @param[in] obj   The SPI peripheral to use for sending
+ * @param[in] value The value to send
+ * @return The status of the write request
+ * @note
+ * - In Master mode, MOSI pin required to be non-NC for this API to operate
+ * - In Slave mode, MISO pin required to be non-NC for this API to operate
+ */
+cy_rslt_t cyhal_spi_write(cyhal_spi_t *obj, uint32_t value);
+
+/** Write a block out and receive a value
+ *
+ *  The total number of bytes sent and received will be the maximum of
+ *  tx_length and rx_length. The bytes written will be padded with the
+ *  value 0xff.
+ *
+ * @param[in] obj           The SPI peripheral to use for sending
+ * @param[in] tx            Pointer to the byte-array of data to write to the device
+ * @param[in,out] tx_length Number of bytes to write, updated with the number actually written
+ * @param[out] rx           Pointer to the byte-array of data to read from the device
+ * @param[in,out] rx_length Number of bytes to read, udpated with the number actually read
+ * @param[in] write_fill    Default data transmitted while performing a read
+ * @return The status of the transfer request
+ * @note Both MOSI and MISO pins required to be non-NC for this API to operate
+ */
+cy_rslt_t cyhal_spi_transfer(cyhal_spi_t *obj, const uint8_t *tx, size_t tx_length, uint8_t *rx, size_t rx_length,
+                             uint8_t write_fill);
+
+/** Begin the SPI transfer. Buffer pointers and lengths are specified in tx_buff and rx_buff
+ *
+ * @param[in] obj           The SPI object that holds the transfer information
+ * @param[in] tx            The transmit buffer
+ * @param[in,out] tx_length The number of bytes to transmit
+ * @param[out] rx           The receive buffer
+ * @param[in,out] rx_length The number of bytes to receive
+ * @return The status of the transfer_async request
+ * @note Both MOSI and MISO pins required to be non-NC for this API to operate
+ */
+cy_rslt_t cyhal_spi_transfer_async(cyhal_spi_t *obj, const uint8_t *tx, size_t tx_length, uint8_t *rx,
+                                   size_t rx_length);
+
+/** Checks if the specified SPI peripheral is in use
+ *
+ * @param[in] obj  The SPI peripheral to check
+ * @return Indication of whether the SPI is still transmitting
+ */
+bool cyhal_spi_is_busy(cyhal_spi_t *obj);
+
+/** Abort an SPI transfer
+ *
+ * @param[in] obj The SPI peripheral to stop
+ * @return The status of the abort_async request
+ */
+cy_rslt_t cyhal_spi_abort_async(cyhal_spi_t *obj);
+
+/** The SPI interrupt handler registration
+ *
+ * @param[in] obj         The SPI object
+ * @param[in] handler     The callback handler which will be invoked when the interrupt fires
+ * @param[in] handler_arg Generic argument that will be provided to the handler when called
+ */
+void cyhal_spi_register_irq(cyhal_spi_t *obj, cyhal_spi_irq_handler_t handler, void *handler_arg);
+
+/** Configure SPI interrupt. This function is used for word-approach
+ *
+ * @param[in] obj      The SPI object
+ * @param[in] event    The SPI IRQ type
+ * @param[in] enable   True to turn on interrupts, False to turn off
+ */
+void cyhal_spi_irq_enable(cyhal_spi_t *obj, cyhal_spi_irq_event_t event, bool enable);
+
+/** \} group_hal_spi_functions */
+
+#if defined(__cplusplus)
+}
+#endif
+
diff --git a/targets/TARGET_STM/TARGET_STM32H7/TARGET_STM32H747xI/TARGET_PORTENTA_H7/COMPONENT_WHD/port/cy_hal.c b/targets/TARGET_STM/TARGET_STM32H7/TARGET_STM32H747xI/TARGET_PORTENTA_H7/COMPONENT_WHD/port/cy_hal.c
new file mode 100644
index 0000000000..bb5f942102
--- /dev/null
+++ b/targets/TARGET_STM/TARGET_STM32H7/TARGET_STM32H747xI/TARGET_PORTENTA_H7/COMPONENT_WHD/port/cy_hal.c
@@ -0,0 +1,76 @@
+/*
+ * Copyright 2020 Arduino SA
+ * SPDX-License-Identifier: Apache-2.0
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+/** @file
+ *  Provides cyhal porting to generic mbed APIs
+ */
+
+#include <stddef.h>
+#include "cyhal_sdio.h"
+#include "cyhal_spi.h"
+#include "cyhal_gpio.h"
+#include <stdio.h>
+#include "sockets.h"
+
+void Cy_SysLib_Delay(uint32_t milliseconds) {
+	thread_sleep_for(milliseconds);
+}
+
+void Cy_SysLib_DelayUs(uint16_t microseconds) {
+	wait_us(microseconds);
+}
+
+static bool filesystem_mounted = false;
+extern bool wiced_filesystem_mount();
+
+int wiced_filesystem_file_open(int* fd, const char* filename) {
+	if (!filesystem_mounted) {
+		filesystem_mounted = wiced_filesystem_mount();
+	}
+	if (!filesystem_mounted) {
+		return WHD_BADARG;
+	}
+	*fd = open(filename, O_RDONLY);
+	if (*fd == -1) {
+		return WHD_BADARG;
+	}
+	return WHD_SUCCESS;
+}
+
+int wiced_filesystem_file_seek(int* fd, uint32_t offset) {
+	if (*fd == -1) {
+		return WHD_BADARG;
+	}
+	lseek(*fd, offset, SEEK_SET);
+	return WHD_SUCCESS;
+}
+
+int wiced_filesystem_file_read(int* fd, void *buffer, uint32_t maxsize, uint32_t* size) {
+	if (*fd == -1) {
+		return WHD_BADARG;
+	}
+	*size = read(*fd, buffer, maxsize);
+	return WHD_SUCCESS;
+}
+
+int wiced_filesystem_file_close(int* fd) {
+	if (*fd == -1) {
+		return WHD_BADARG;
+	}
+	close(*fd);
+	return WHD_SUCCESS;
+}
diff --git a/targets/TARGET_STM/TARGET_STM32H7/TARGET_STM32H747xI/TARGET_PORTENTA_H7/COMPONENT_WHD/port/cy_syslib.h b/targets/TARGET_STM/TARGET_STM32H7/TARGET_STM32H747xI/TARGET_PORTENTA_H7/COMPONENT_WHD/port/cy_syslib.h
new file mode 100644
index 0000000000..7671d853cf
--- /dev/null
+++ b/targets/TARGET_STM/TARGET_STM32H7/TARGET_STM32H747xI/TARGET_PORTENTA_H7/COMPONENT_WHD/port/cy_syslib.h
@@ -0,0 +1,592 @@
+/***************************************************************************//**
+* \file cy_syslib.h
+* \version 2.40.1
+*
+* Provides an API declaration of the SysLib driver.
+*
+********************************************************************************
+* \copyright
+* Copyright 2016-2019 Cypress Semiconductor Corporation
+* SPDX-License-Identifier: Apache-2.0
+*
+* Licensed under the Apache License, Version 2.0 (the "License");
+* you may not use this file except in compliance with the License.
+* You may obtain a copy of the License at
+*
+*     http://www.apache.org/licenses/LICENSE-2.0
+*
+* Unless required by applicable law or agreed to in writing, software
+* distributed under the License is distributed on an "AS IS" BASIS,
+* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+* See the License for the specific language governing permissions and
+* limitations under the License.
+*******************************************************************************/
+
+/**
+* \addtogroup group_syslib
+* \{
+* The system libraries provide APIs that can be called in the user application
+* to handle the timing, logical checking or register.
+*
+* The functions and other declarations used in this driver are in cy_syslib.h. 
+* You can include cy_pdl.h (ModusToolbox only) to get access to all functions 
+* and declarations in the PDL. 
+*
+* The SysLib driver contains a set of different system functions. These functions
+* can be called in the application routine. Major features of the system library:
+* * Delay functions
+* * The register Read/Write macro
+* * Assert and Halt
+* * Assert Classes and Levels
+* * A software reset
+* * Reading the reset cause
+* * An API to invalidate the flash cache and buffer
+* * Data manipulation macro
+* * A variable type definition from MISRA-C which specifies signedness
+* * Cross compiler compatible attributes
+* * Getting a silicon-unique ID API
+* * Setting wait states API
+* * Resetting the backup domain API
+* * APIs to serve Fault handler
+*
+* \section group_syslib_configuration Configuration Considerations
+* <b> Assertion Usage </b> <br />
+* Use the CY_ASSERT() macro to check expressions that must be true as long as the
+* program is running correctly. It is a convenient way to insert sanity checks.
+* The CY_ASSERT() macro is defined in the cy_syslib.h file which is part of
+* the PDL library. The behavior of the macro is as follows: if the expression
+* passed to the macro is false, output an error message that includes the file
+* name and line number, and then halts the CPU. \n
+* In case of fault, the CY_ASSERT() macro calls the Cy_SysLib_AssertFailed() function.
+* This is a weakly linked function. The default implementation stores the file
+* name and line number of the ASSERT into global variables, cy_assertFileName
+* and cy_assertLine . It then calls the Cy_SysLib_Halt() function.
+* \note Firmware can redefine the Cy_SysLib_AssertFailed() function for custom processing.
+* 
+* The PDL source code uses this assert mechanism extensively. It is recommended
+* that you enable asserts when debugging firmware. \n
+* <b> Assertion Classes and Levels </b> <br />
+* The PDL defines three assert classes, which correspond to different kinds
+* of parameters. There is a corresponding assert "level" for each class.
+* <table class="doxtable">
+*   <tr><th>Class Macro</th><th>Level Macro</th><th>Type of check</th></tr>
+*   <tr>
+*     <td>CY_ASSERT_CLASS_1</td>
+*     <td>CY_ASSERT_L1</td>
+*     <td>A parameter that could change between different PSoC devices
+*         (e.g. the number of clock paths)</td>
+*   </tr>
+*   <tr>
+*     <td>CY_ASSERT_CLASS_2</td>
+*     <td>CY_ASSERT_L2</td>
+*     <td>A parameter that has fixed limits such as a counter period</td>
+*   </tr>
+*   <tr>
+*     <td>CY_ASSERT_CLASS_3</td>
+*     <td>CY_ASSERT_L3</td>
+*     <td>A parameter that is an enum constant</td>
+*   </tr>
+* </table>
+* Firmware defines which ASSERT class is enabled by defining CY_ASSERT_LEVEL.
+* This is a compiler command line argument, similar to how the DEBUG / NDEBUG
+* macro is passed. \n 
+* Enabling any class also enables any lower-numbered class.
+* CY_ASSERT_CLASS_3 is the default level, and it enables asserts for all three
+* classes. The following example shows the command-line option to enable all
+* the assert levels:
+* \code -D CY_ASSERT_LEVEL=CY_ASSERT_CLASS_3 \endcode
+* \note The use of special characters, such as spaces, parenthesis, etc. must
+* be protected with quotes. 
+* 
+* After CY_ASSERT_LEVEL is defined, firmware can use
+* one of the three level macros to make an assertion. For example, if the
+* parameter can vary between devices, firmware uses the L1 macro.
+* \code CY_ASSERT_L1(clkPath < SRSS_NUM_CLKPATH); \endcode
+* If the parameter has bounds, firmware uses L2.
+* \code CY_ASSERT_L2(trim <= CY_CTB_TRIM_VALUE_MAX); \endcode
+* If the parameter is an enum, firmware uses L3.
+* \code CY_ASSERT_L3(config->LossAction <= CY_SYSCLK_CSV_ERROR_FAULT_RESET); \endcode
+* Each check uses the appropriate level macro for the kind of parameter being checked.
+* If a particular assert class/level is not enabled, then the assert does nothing.
+*
+* \section group_syslib_more_information More Information
+* Refer to the technical reference manual (TRM).
+*
+* \section group_syslib_MISRA MISRA-C Compliance
+* <table class="doxtable">
+*   <tr>
+*     <th>MISRA Rule</th>
+*     <th>Rule Class (Required/Advisory)</th>
+*     <th>Rule Description</th>
+*     <th>Description of Deviation(s)</th>
+*   </tr>
+*   <tr>
+*     <td>1.2</td>
+*     <td>R</td>
+*     <td>No reliance shall be placed on undefined or unspecified behaviour.</td>
+*     <td>This specific behavior is explicitly covered in rule 20.1.</td>
+*   </tr>
+*   <tr>
+*     <td>2.1</td>
+*     <td>R</td>
+*     <td>This function contains a mixture of in-line assembler statements and C statements.</td>
+*     <td>This si required by design of the Cy_SysLib_Halt function.</td>
+*   </tr>
+*   <tr>
+*     <td>18.4</td>
+*     <td>R</td>
+*     <td>Unions shall not be used.</td>
+*     <td>The unions are used for CFSR, HFSR and SHCSR Fault Status Registers
+*         content access as a word in code and as a structure during debug.</td>
+*   </tr>
+*   <tr>
+*     <td>19.13</td>
+*     <td>A</td>
+*     <td>The # and ## operators should not be used.</td>
+*     <td>The ## preprocessor operator is used in macros to form the field mask.</td>
+*   </tr>
+*   <tr>
+*     <td>20.1</td>
+*     <td>R</td>
+*     <td>Reserved identifiers, macros and functions in the standard library, shall not be 
+*         defined, redefined or undefined.</td>
+*     <td>The driver defines the macros with leading underscores 
+*         (_CLR_SET_FLD/_BOOL2FLD/_FLD2BOOL) and therefore generates this MISRA violation.</td>
+*   </tr>
+* </table>
+*
+* \section group_syslib_changelog Changelog
+* <table class="doxtable">
+*   <tr><th>Version</th><th>Changes</th><th>Reason for Change</th></tr>
+*   <tr>
+*     <td>2.40.1</td>
+*     <td>Correct the CY_RAMFUNC_BEGIN macro for the IAR compiler.</td>
+*     <td>Removed the IAR compiler warning.</td>
+*   </tr>
+*   <tr>
+*     <td>2.40</td>
+*     <td>Added new macros CY_SYSLIB_DIV_ROUND and CY_SYSLIB_DIV_ROUNDUP to easy perform integer division with rounding.</td>
+*     <td>Improve PDL code base.</td>
+*   </tr>
+*   <tr>
+*     <td rowspan="3">2.30</td>
+*     <td>Updated implementation of the Cy_SysLib_AsmInfiniteLoop() function to be compatible with ARMC6.</td>
+*     <td>Provided support for the ARM Compiler 6.</td>
+*   </tr>
+*   <tr>
+*     <td>Minor documentation edits.</td>
+*     <td>Documentation update and clarification.</td>
+*   </tr>
+*	<tr>
+*     <td>Added new macros CY_RAMFUNC_BEGIN and CY_RAMFUNC_END for convenient placement function in RAM for all supported compilers.</td>
+*     <td>Improve user experience.</td>
+*   </tr>
+*   <tr>
+*     <td rowspan="2">2.20</td>
+*     <td>Updated implementation of the \ref Cy_SysLib_AssertFailed() function to be available in Release and Debug modes.</td>
+*     <td>Provided support for the PDL static library in Release mode.</td>
+*   </tr>
+*   <tr>
+*     <td>Minor documentation edits.</td>
+*     <td>Documentation update and clarification.</td>
+*   </tr>
+*   <tr>
+*     <td rowspan="4">2.10</td>
+*     <td>Flattened the organization of the driver source code into the single source directory and the single include directory.</td>
+*     <td>Driver library directory-structure simplification.</td>
+*   </tr>
+*   <tr>
+*     <td>Added the following macros: \ref CY_REG32_CLR_SET, \ref _CLR_SET_FLD16U, \ref CY_REG16_CLR_SET, \ref _CLR_SET_FLD8U, \ref CY_REG8_CLR_SET</td>
+*     <td>Register access simplification.</td>
+*   </tr>
+*   <tr>
+*     <td>Removed the Cy_SysLib_GetNumHfclkResetCause API function.</td>
+*     <td>This feature is not supported by SRSS_ver1.</td>
+*   </tr>
+*   <tr>
+*     <td>Added register access layer. Use register access macros instead
+*         of direct register access using dereferenced pointers.</td>
+*     <td>Makes register access device-independent, so that the PDL does 
+*         not need to be recompiled for each supported part number.</td>
+*   </tr>
+*   <tr>
+*     <td>2.0.1</td>
+*     <td>Minor documentation edits</td>
+*     <td>Documentation update and clarification</td>
+*   </tr>
+*   <tr>
+*     <td rowspan="4"> 2.0</td>
+*     <td>
+* Added Cy_SysLib_ResetBackupDomain() API implementation. \n
+* Added CY_NOINLINE attribute implementation. \n
+* Added DIE_YEAR field to 64-bit unique ID return value of Cy_SysLib_GetUniqueId() API. \n
+* Added storing of SCB->HFSR, SCB->SHCSR registers and SCB->MMFAR, SCB->BFAR addresses to Fault Handler debug structure. \n
+* Optimized Cy_SysLib_SetWaitStates() API implementation.
+*     </td>
+*     <td>Improvements made based on usability feedback.</td>
+*   </tr>
+*   <tr>
+*     <td>Added Assertion Classes and Levels.</td>
+*     <td>For error checking, parameter validation and status returns in the PDL API.</td>
+*   </tr>
+*   <tr>
+*     <td>Applied CY_NOINIT attribute to cy_assertFileName, cy_assertLine, and cy_faultFrame global variables.</td>
+*     <td>To store debug information into a non-zero init area for future analysis.</td>
+*   </tr>
+*   <tr>
+*     <td>Removed CY_WEAK attribute implementation.</td>
+*     <td>CMSIS __WEAK attribute should be used instead.</td>
+*   </tr>
+*   <tr>
+*     <td>1.0</td>
+*     <td>Initial version</td>
+*     <td></td>
+*   </tr>
+* </table>
+*
+* \defgroup group_syslib_macros Macros
+* \defgroup group_syslib_functions Functions
+* \defgroup group_syslib_data_structures Data Structures
+* \defgroup group_syslib_enumerated_types Enumerated Types
+*
+*/
+
+#if !defined(CY_SYSLIB_H)
+#define CY_SYSLIB_H
+
+#include <stdint.h>
+#include <stdbool.h>
+
+/*******************************************************************************
+*  Data manipulation defines
+*******************************************************************************/
+
+/** Get the lower 8 bits of a 16-bit value. */
+#define CY_LO8(x)               ((uint8_t) ((x) & 0xFFU))
+/** Get the upper 8 bits of a 16-bit value. */
+#define CY_HI8(x)               ((uint8_t) ((uint16_t)(x) >> 8U))
+
+/** Get the lower 16 bits of a 32-bit value. */
+#define CY_LO16(x)              ((uint16_t) ((x) & 0xFFFFU))
+/** Get the upper 16 bits of a 32-bit value. */
+#define CY_HI16(x)              ((uint16_t) ((uint32_t)(x) >> 16U))
+
+/** Swap the byte ordering of a 16-bit value */
+#define CY_SWAP_ENDIAN16(x)     ((uint16_t)(((x) << 8U) | (((x) >> 8U) & 0x00FFU)))
+
+/** Swap the byte ordering of a 32-bit value */
+#define CY_SWAP_ENDIAN32(x)     ((uint32_t)((((x) >> 24U) & 0x000000FFU) | (((x) & 0x00FF0000U) >> 8U) | \
+                                (((x) & 0x0000FF00U) << 8U) | ((x) << 24U)))
+
+/** Swap the byte ordering of a 64-bit value */
+#define CY_SWAP_ENDIAN64(x)     ((uint64_t) (((uint64_t) CY_SWAP_ENDIAN32((uint32_t)(x)) << 32U) | \
+                                CY_SWAP_ENDIAN32((uint32_t)((x) >> 32U))))
+
+/* MISRA rule 6.3 recommends using specific-length typedef for the basic
+ * numerical types of signed and unsigned variants of char, float, and double.
+ */
+typedef char     char_t;    /**< Specific-length typedef for the basic numerical types of char */
+typedef float    float32_t; /**< Specific-length typedef for the basic numerical types of float */
+typedef double   float64_t; /**< Specific-length typedef for the basic numerical types of double */
+
+
+/*******************************************************************************
+* Macro Name: CY_GET_REG8(addr)
+****************************************************************************//**
+*
+* Reads the 8-bit value from the specified address. This function can't be
+* used to access the Core register, otherwise a fault occurs.
+*
+* \param addr  The register address.
+*
+* \return The read value.
+*
+*******************************************************************************/
+#define CY_GET_REG8(addr)           (*((const volatile uint8_t *)(addr)))
+
+
+/*******************************************************************************
+* Macro Name: CY_SET_REG8(addr, value)
+****************************************************************************//**
+*
+* Writes an 8-bit value to the specified address. This function can't be
+* used to access the Core register, otherwise a fault occurs.
+*
+* \param addr  The register address.
+*
+* \param value The value to write.
+*
+*******************************************************************************/
+#define CY_SET_REG8(addr, value)    (*((volatile uint8_t *)(addr)) = (uint8_t)(value))
+
+
+/*******************************************************************************
+* Macro Name: CY_GET_REG16(addr)
+****************************************************************************//**
+*
+* Reads the 16-bit value from the specified address.
+*
+* \param addr  The register address.
+*
+* \return The read value.
+*
+*******************************************************************************/
+#define CY_GET_REG16(addr)          (*((const volatile uint16_t *)(addr)))
+
+
+/*******************************************************************************
+* Macro Name: CY_SET_REG16(addr, value)
+****************************************************************************//**
+*
+* Writes the 16-bit value to the specified address.
+*
+* \param addr  The register address.
+*
+* \param value The value to write.
+*
+*******************************************************************************/
+#define CY_SET_REG16(addr, value)   (*((volatile uint16_t *)(addr)) = (uint16_t)(value))
+
+
+/*******************************************************************************
+* Macro Name: CY_GET_REG24(addr)
+****************************************************************************//**
+*
+* Reads the 24-bit value from the specified address.
+*
+* \param addr  The register address.
+*
+* \return The read value.
+*
+*******************************************************************************/
+#define CY_GET_REG24(addr)          (((uint32_t) (*((const volatile uint8_t *)(addr)))) | \
+                                    (((uint32_t) (*((const volatile uint8_t *)(addr) + 1))) << 8U) | \
+                                    (((uint32_t) (*((const volatile uint8_t *)(addr) + 2))) << 16U))                                    
+
+
+/*******************************************************************************
+* Macro Name: CY_SET_REG24(addr, value)
+****************************************************************************//**
+*
+* Writes the 24-bit value to the specified address.
+*
+* \param addr  The register address.
+*
+* \param value The value to write.
+*
+*******************************************************************************/
+#define CY_SET_REG24(addr, value)   do  \
+                                    {   \
+                                        (*((volatile uint8_t *) (addr))) = (uint8_t)(value);                \
+                                        (*((volatile uint8_t *) (addr) + 1)) = (uint8_t)((value) >> 8U);    \
+                                        (*((volatile uint8_t *) (addr) + 2)) = (uint8_t)((value) >> 16U);   \
+                                    }   \
+                                    while(0)
+
+
+/*******************************************************************************
+* Macro Name: CY_GET_REG32(addr)
+****************************************************************************//**
+*
+* Reads the 32-bit value from the specified register. The address is the little
+* endian order (LSB in lowest address).
+*
+* \param addr  The register address.
+*
+* \return The read value.
+*
+*******************************************************************************/
+#define CY_GET_REG32(addr)          (*((const volatile uint32_t *)(addr)))
+
+
+/*******************************************************************************
+* Macro Name: CY_SET_REG32(addr, value)
+****************************************************************************//**
+*
+* Writes the 32-bit value to the specified register. The address is the little
+* endian order (LSB in lowest address).
+*
+* \param addr  The register address.
+*
+* \param value The value to write.
+*
+*******************************************************************************/
+#define CY_SET_REG32(addr, value)   (*((volatile uint32_t *)(addr)) = (uint32_t)(value))
+
+/*******************************************************************************
+* Macro Name: _CLR_SET_FLD32U
+****************************************************************************//**
+*
+*  The macro for setting a register with a name field and value for providing
+*  get-clear-modify-write operations.
+*  Returns a resulting value to be assigned to the register.
+*
+*******************************************************************************/
+#define _CLR_SET_FLD32U(reg, field, value) (((reg) & ((uint32_t)(~(field ## _Msk)))) | (_VAL2FLD(field, value)))
+
+
+/*******************************************************************************
+* Macro Name: CY_REG32_CLR_SET
+****************************************************************************//**
+*
+*  Uses _CLR_SET_FLD32U macro for providing get-clear-modify-write 
+*  operations with a name field and value and writes a resulting value 
+*  to the 32-bit register.
+*
+*******************************************************************************/
+#define CY_REG32_CLR_SET(reg, field, value) ((reg) = _CLR_SET_FLD32U((reg), field, (value)))
+
+
+/*******************************************************************************
+* Macro Name: _CLR_SET_FLD16U
+****************************************************************************//**
+*
+*  The macro for setting a 16-bit register with a name field and value for providing
+*  get-clear-modify-write operations.
+*  Returns a resulting value to be assigned to the 16-bit register.
+*
+*******************************************************************************/
+#define _CLR_SET_FLD16U(reg, field, value) ((uint16_t)(((reg) & ((uint16_t)(~(field ## _Msk)))) |   \
+                                                       ((uint16_t)_VAL2FLD(field, value))))
+                                                       
+                                                       
+/*******************************************************************************
+* Macro Name: CY_REG16_CLR_SET
+****************************************************************************//**
+*
+*  Uses _CLR_SET_FLD16U macro for providing get-clear-modify-write 
+*  operations with a name field and value and writes a resulting value 
+*  to the 16-bit register.
+*
+*******************************************************************************/
+#define CY_REG16_CLR_SET(reg, field, value) ((reg) = _CLR_SET_FLD16U((reg), field, (value)))
+
+
+/*******************************************************************************
+* Macro Name: _CLR_SET_FLD8U
+****************************************************************************//**
+*
+*  The macro for setting a 8-bit register with a name field and value for providing
+*  get-clear-modify-write operations.
+*  Returns a resulting value to be assigned to the 8-bit register.
+*
+*******************************************************************************/
+#define _CLR_SET_FLD8U(reg, field, value) ((uint8_t)(((reg) & ((uint8_t)(~(field ## _Msk)))) |  \
+                                                     ((uint8_t)_VAL2FLD(field, value))))
+                                                     
+                                                     
+/*******************************************************************************
+* Macro Name: CY_REG8_CLR_SET
+****************************************************************************//**
+*
+*  Uses _CLR_SET_FLD8U macro for providing get-clear-modify-write 
+*  operations with a name field and value and writes a resulting value 
+*  to the 8-bit register.
+*
+*******************************************************************************/
+#define CY_REG8_CLR_SET(reg, field, value) ((reg) = _CLR_SET_FLD8U((reg), field, (value)))
+
+
+/*******************************************************************************
+* Macro Name: _BOOL2FLD
+****************************************************************************//**
+*
+*  Returns a field mask if the value is not false.
+*  Returns 0, if the value is false.
+*
+*******************************************************************************/
+#define _BOOL2FLD(field, value) (((value) != false) ? (field ## _Msk) : 0UL)
+
+
+/*******************************************************************************
+* Macro Name: _FLD2BOOL
+****************************************************************************//**
+*
+*  Returns true, if the value includes the field mask.
+*  Returns false, if the value doesn't include the field mask.
+*
+*******************************************************************************/
+#define _FLD2BOOL(field, value) (((value) & (field ## _Msk)) != 0UL)
+
+
+/*******************************************************************************
+* Macro Name: CY_SYSLIB_DIV_ROUND
+****************************************************************************//**
+*
+*  Calculates a / b with rounding to the nearest integer,
+*  a and b must have the same sign.
+*
+*******************************************************************************/
+#define CY_SYSLIB_DIV_ROUND(a, b) (((a) + ((b) / 2U)) / (b))
+
+
+/*******************************************************************************
+* Macro Name: CY_SYSLIB_DIV_ROUNDUP
+****************************************************************************//**
+*
+*  Calculates a / b with rounding up if remainder != 0,
+*  both a and b must be positive.
+*
+*******************************************************************************/
+#define CY_SYSLIB_DIV_ROUNDUP(a, b) ((((a) - 1U) / (b)) + 1U)
+
+typedef uint32_t cy_status;
+/** The ARM 32-bit status value for backward compatibility with the UDB components. Do not use it in your code. */
+typedef uint32_t cystatus;
+typedef uint8_t  uint8;    /**< Alias to uint8_t  for backward compatibility */
+typedef uint16_t uint16;   /**< Alias to uint16_t for backward compatibility */
+typedef uint32_t uint32;   /**< Alias to uint32_t for backward compatibility */
+typedef int8_t   int8;     /**< Alias to int8_t   for backward compatibility */
+typedef int16_t  int16;    /**< Alias to int16_t  for backward compatibility */
+typedef int32_t  int32;    /**< Alias to int32_t  for backward compatibility */
+typedef float    float32;  /**< Alias to float    for backward compatibility */
+typedef double   float64;  /**< Alias to double   for backward compatibility */
+typedef int64_t  int64;    /**< Alias to int64_t  for backward compatibility */
+typedef uint64_t uint64;   /**< Alias to uint64_t for backward compatibility */
+/* Signed or unsigned depending on the compiler selection */
+typedef char     char8;    /**< Alias to char for backward compatibility */
+typedef volatile uint8_t  reg8;   /**< Alias to uint8_t  for backward compatibility */
+typedef volatile uint16_t reg16;  /**< Alias to uint16_t for backward compatibility */
+typedef volatile uint32_t reg32;  /**< Alias to uint32_t for backward compatibility */
+
+/** The ARM 32-bit Return error / status code for backward compatibility.
+*  Do not use them in your code.
+*/
+#define CY_RET_SUCCESS           (0x00U)    /* Successful */
+#define CY_RET_BAD_PARAM         (0x01U)    /* One or more invalid parameters */
+#define CY_RET_INVALID_OBJECT    (0x02U)    /* An invalid object specified */
+#define CY_RET_MEMORY            (0x03U)    /* A memory-related failure */
+#define CY_RET_LOCKED            (0x04U)    /* A resource lock failure */
+#define CY_RET_EMPTY             (0x05U)    /* No more objects available */
+#define CY_RET_BAD_DATA          (0x06U)    /* Bad data received (CRC or other error check) */
+#define CY_RET_STARTED           (0x07U)    /* Operation started, but not necessarily completed yet */
+#define CY_RET_FINISHED          (0x08U)    /* Operation is completed */
+#define CY_RET_CANCELED          (0x09U)    /* Operation is canceled */
+#define CY_RET_TIMEOUT           (0x10U)    /* Operation timed out */
+#define CY_RET_INVALID_STATE     (0x11U)    /* Operation is not setup or is in an improper state */
+#define CY_RET_UNKNOWN           ((cy_status) 0xFFFFFFFFU)    /* Unknown failure */
+
+/** ARM 32-bit Return error / status codes for backward compatibility with the UDB components.
+*  Do not use them in your code.
+*/
+#define CYRET_SUCCESS            (0x00U)    /* Successful */
+#define CYRET_BAD_PARAM          (0x01U)    /* One or more invalid parameters */
+#define CYRET_INVALID_OBJECT     (0x02U)    /* An invalid object specified */
+#define CYRET_MEMORY             (0x03U)    /* A memory-related failure */
+#define CYRET_LOCKED             (0x04U)    /* A resource lock failure */
+#define CYRET_EMPTY              (0x05U)    /* No more objects available */
+#define CYRET_BAD_DATA           (0x06U)    /* Bad data received (CRC or other error check) */
+#define CYRET_STARTED            (0x07U)    /* Operation started, but not necessarily completed yet */
+#define CYRET_FINISHED           (0x08U)    /* Operation is completed */
+#define CYRET_CANCELED           (0x09U)    /* Operation is canceled */
+#define CYRET_TIMEOUT            (0x10U)    /* Operation timed out */
+#define CYRET_INVALID_STATE      (0x11U)    /* Operation is not setup or is in an improper state */
+#define CYRET_UNKNOWN            ((cystatus) 0xFFFFFFFFU)    /* Unknown failure */
+
+/** \} group_syslib_functions */
+
+#endif /* CY_SYSLIB_H */
+
+/** \} group_syslib */
+
+/* [] END OF FILE */
diff --git a/targets/TARGET_STM/TARGET_STM32H7/TARGET_STM32H747xI/TARGET_PORTENTA_H7/COMPONENT_WHD/port/cy_utils.h b/targets/TARGET_STM/TARGET_STM32H7/TARGET_STM32H747xI/TARGET_PORTENTA_H7/COMPONENT_WHD/port/cy_utils.h
new file mode 100644
index 0000000000..30a99344c1
--- /dev/null
+++ b/targets/TARGET_STM/TARGET_STM32H7/TARGET_STM32H747xI/TARGET_PORTENTA_H7/COMPONENT_WHD/port/cy_utils.h
@@ -0,0 +1,79 @@
+/***************************************************************************//**
+* \file cy_utils.h
+*
+* \brief
+* Basic utility macros and functions.
+*
+********************************************************************************
+* \copyright
+* Copyright 2018-2019 Cypress Semiconductor Corporation
+* SPDX-License-Identifier: Apache-2.0
+*
+* Licensed under the Apache License, Version 2.0 (the "License");
+* you may not use this file except in compliance with the License.
+* You may obtain a copy of the License at
+*
+*     http://www.apache.org/licenses/LICENSE-2.0
+*
+* Unless required by applicable law or agreed to in writing, software
+* distributed under the License is distributed on an "AS IS" BASIS,
+* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+* See the License for the specific language governing permissions and
+* limitations under the License.
+*******************************************************************************/
+
+/**
+* \addtogroup group_utils Utilities
+* \ingroup group_abstraction
+* \{
+* Basic utility macros and functions.
+*
+* \defgroup group_utils_macros Macros
+*/
+
+#pragma once
+
+#if defined(__cplusplus)
+extern "C" {
+#endif
+
+/**
+* \addtogroup group_utils_macros
+* \{
+*/
+
+/** Simple macro to supress the unused parameter warning by casting to void. */
+#define CY_UNUSED_PARAMETER(x) ( (void)(x) )
+
+/** Halt the processor in the debug state
+ * @return
+ */
+static inline uint32_t CY_HALT()
+{
+    __asm("    bkpt    1");
+    return 0;
+}
+
+#ifdef CY_ASSERT
+#undef CY_ASSERT
+#endif /* ifdef(CY_ASSERT) */
+
+/** Utility macro when neither NDEBUG or CY_NO_ASSERT is not declared to check a condition and, if false, trigger a breakpoint */
+#if defined(NDEBUG) || defined(CY_NO_ASSERT)
+    #define CY_ASSERT(x)    CY_UNUSED_PARAMETER(x)
+#else
+    #define CY_ASSERT(x)    do {                \
+                                if(!(x))        \
+                                {               \
+                                    CY_HALT();  \
+                                }               \
+                            } while(0)
+#endif  /* defined(NDEBUG) */
+
+/** \} group_utils_macros */
+
+#ifdef __cplusplus
+}
+#endif
+
+/** \} group_utils */
diff --git a/targets/TARGET_STM/TARGET_STM32H7/TARGET_STM32H747xI/TARGET_PORTENTA_H7/COMPONENT_WHD/port/cybsp_wifi.c b/targets/TARGET_STM/TARGET_STM32H7/TARGET_STM32H747xI/TARGET_PORTENTA_H7/COMPONENT_WHD/port/cybsp_wifi.c
new file mode 100644
index 0000000000..a169f3fcff
--- /dev/null
+++ b/targets/TARGET_STM/TARGET_STM32H7/TARGET_STM32H747xI/TARGET_PORTENTA_H7/COMPONENT_WHD/port/cybsp_wifi.c
@@ -0,0 +1,219 @@
+/***************************************************************************//**
+* \file cybsp_wifi.c
+*
+* \brief
+* Provides utility functions that are used by board support packages.
+* 
+********************************************************************************
+* \copyright
+* Copyright 2018-2019 Cypress Semiconductor Corporation
+* SPDX-License-Identifier: Apache-2.0
+*
+* Licensed under the Apache License, Version 2.0 (the "License");
+* you may not use this file except in compliance with the License.
+* You may obtain a copy of the License at
+*
+*     http://www.apache.org/licenses/LICENSE-2.0
+*
+* Unless required by applicable law or agreed to in writing, software
+* distributed under the License is distributed on an "AS IS" BASIS,
+* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+* See the License for the specific language governing permissions and
+* limitations under the License.
+*******************************************************************************/
+
+#include "cy_network_buffer.h"
+#include "cyabs_rtos.h"
+#include "whd_types.h"
+#include "whd_config.h"
+#include "whd_wifi_api.h"
+#include "cyhal_sdio.h"
+
+#if defined(__cplusplus)
+extern "C" {
+#endif
+
+static whd_driver_t whd_drv;
+
+static whd_buffer_funcs_t buffer_ops =
+{
+    .whd_host_buffer_get = cy_host_buffer_get,
+    .whd_buffer_release = cy_buffer_release,
+    .whd_buffer_get_current_piece_data_pointer = cy_buffer_get_current_piece_data_pointer,
+    .whd_buffer_get_current_piece_size = cy_buffer_get_current_piece_size,
+    .whd_buffer_set_size = cy_buffer_set_size,
+    .whd_buffer_add_remove_at_front = cy_buffer_add_remove_at_front,
+};
+
+static whd_netif_funcs_t netif_ops =
+{
+    .whd_network_process_ethernet_data = cy_network_process_ethernet_data,
+};
+
+//TODO: Need to use resource implemenatation from abstraction layer.
+extern whd_resource_source_t resource_ops;
+
+typedef enum
+{
+  CYBSP_WIFI_WL_REG_ON,
+  CYBSP_WIFI_32K_CLK,
+  CYBSP_LED1,
+  CYBSP_LED2,
+  CYBSP_WIFI_SDIO_CMD,
+  CYBSP_WIFI_SDIO_CLK,
+  CYBSP_WIFI_SDIO_D0,
+  CYBSP_WIFI_SDIO_D1,
+  CYBSP_WIFI_SDIO_D2,
+  CYBSP_WIFI_SDIO_D3,
+  CYBSP_SDIO_OOB_IRQ,
+  CYBSP_WIFI_MAX,
+} wwd_sdio_pin_t;
+
+/* Edit  Pin configuration */
+const pinconfig_t PinConfig[]={  
+
+    [CYBSP_WIFI_WL_REG_ON] = WIFI_WL_REG_ON,
+#ifdef CYBSP_WIFI_32K_CLK
+    [CYBSP_WIFI_32K_CLK]  =  WIFI_32K_CLK,
+#endif /* CYBSP_WIFI_32K_CLK */
+    [CYBSP_LED1    ]      =  BSP_LED1,
+    [CYBSP_LED2    ]      =  BSP_LED2,
+    [CYBSP_WIFI_SDIO_CMD] =  WIFI_SDIO_CMD,
+    [CYBSP_WIFI_SDIO_CLK] =  WIFI_SDIO_CLK,
+    [CYBSP_WIFI_SDIO_D0 ] =  WIFI_SDIO_D0,
+    [CYBSP_WIFI_SDIO_D1 ] =  WIFI_SDIO_D1,
+    [CYBSP_WIFI_SDIO_D2 ] =  WIFI_SDIO_D2,
+    [CYBSP_WIFI_SDIO_D3 ] =  WIFI_SDIO_D3,
+    [CYBSP_SDIO_OOB_IRQ ] =  WIFI_SDIO_OOB_IRQ //VIKR
+};
+
+whd_sdio_config_t       sdio_config=
+{
+    /* Bus config */
+    .sdio_1bit_mode = false,       /**< Default is false, means SDIO operates under 4 bit mode */
+    .high_speed_sdio_clock = false, /**< Default is false, means SDIO operates in normal clock rate */
+    .oob_config = {
+      /**< Out-of-band interrupt configuration (required when bus can sleep) */
+    .host_oob_pin = CYBSP_SDIO_OOB_IRQ,   /**< Host-side GPIO pin selection CYHAL_NC_PIN_VALUE or CYBSP_SDIO_OOB_IRQ */
+    .dev_gpio_sel = 0,        /**< WiFi device-side GPIO pin selection (must be zero) */
+    .is_falling_edge = true,  /**< Interrupt trigger (polarity) */
+    .intr_priority = 0,       /**< OOB interrupt priority */
+    } 
+};
+
+cy_rslt_t sdio_enumerate( cyhal_sdio_t   *sdhc_obj )
+{
+    cy_rslt_t result;
+    uint32_t     loop_count = 0;
+    uint32_t     data = 0;
+    do
+    {
+        /* Send CMD0 to set it to idle state in SDIO_BYTE_MODE, SDIO_1B_BLOCK */
+        cyhal_sdio_send_cmd( sdhc_obj, CYHAL_WRITE, CYHAL_SDIO_CMD_GO_IDLE_STATE, 0,NULL );
+
+        /* CMD5. */
+        cyhal_sdio_send_cmd( sdhc_obj, CYHAL_READ, CYHAL_SDIO_CMD_IO_SEND_OP_COND, 0,NULL);
+
+        /* Send CMD3 to get RCA. */
+        result = cyhal_sdio_send_cmd(sdhc_obj,  CYHAL_READ, CYHAL_SDIO_CMD_SEND_RELATIVE_ADDR,0, &data );
+        loop_count++;
+        if ( loop_count >= (uint32_t) SDIO_ENUMERATION_TIMEOUT_MS )
+        {
+            return -1;
+        }
+
+    } while ( ( result != CY_RSLT_SUCCESS ) && ( cy_rtos_delay_milliseconds( (uint32_t) 1 ), ( 1 == 1 ) ) );
+    /* If you're stuck here, check the platform matches your hardware */
+
+    /* Send CMD7 with the returned RCA to select the card */
+    cyhal_sdio_send_cmd(sdhc_obj,  CYHAL_WRITE, CYHAL_SDIO_CMD_SELECT_CARD,data, &data);
+    return result;
+}
+
+cy_rslt_t whd_init_hardware_sdio(cyhal_sdio_t   *sdhc_obj)
+{
+   /* WiFi no power */
+    cy_rslt_t result = cyhal_gpio_init(CYBSP_WIFI_WL_REG_ON, CYHAL_GPIO_DIR_OUTPUT, CYHAL_GPIO_DRIVE_PULLUP,0);
+ 
+ #ifdef CYBSP_WIFI_32K_CLK
+   result = cyhal_gpio_init(CYBSP_WIFI_32K_CLK, CYHAL_GPIO_DIR_INPUT, CYHAL_GPIO_DRIVE_PULLUP,0);
+   cyhal_gpio_write(CYBSP_WIFI_32K_CLK, false);
+#endif
+
+    if(result == CY_RSLT_SUCCESS)
+    {
+        /* Init SDIO Host */
+        result = cyhal_sdio_init(sdhc_obj, CYBSP_WIFI_SDIO_CMD, CYBSP_WIFI_SDIO_CLK, CYBSP_WIFI_SDIO_D0, CYBSP_WIFI_SDIO_D1, CYBSP_WIFI_SDIO_D2, CYBSP_WIFI_SDIO_D3);;
+        
+        if(result == CY_RSLT_SUCCESS)
+        {
+            /* WiFi put power  */
+            cyhal_gpio_write(CYBSP_WIFI_WL_REG_ON, true);
+            osDelay(WLAN_POWER_UP_DELAY_MS);
+        }
+      result=sdio_enumerate(sdhc_obj);
+
+      if(result == CY_RSLT_SUCCESS) sdio_enable_high_speed();
+
+    }
+    return result;
+}
+
+static cy_rslt_t init_sdio_bus(whd_driver_t* drv, cyhal_sdio_t   *sdhc_obj)
+{
+    cy_rslt_t res = whd_init_hardware_sdio(sdhc_obj);
+    if (res != CY_RSLT_SUCCESS) {
+        return res;
+    }
+    return whd_bus_sdio_attach(*drv, &sdio_config, sdhc_obj);
+}
+
+cyhal_sdio_t   sdhc_obj;
+
+cy_rslt_t cybsp_wifi_init_primary(whd_interface_t* interface)
+{
+    whd_init_config_t whd_init_config;
+    whd_init_config.thread_stack_size = (uint32_t)WHD_THREAD_STACK_SIZE;
+    whd_init_config.thread_stack_start = NULL;
+    whd_init_config.thread_priority =  (uint32_t)WHD_THREAD_PRIORITY;
+    whd_init_config.country = WHD_COUNTRY;
+
+    cy_rslt_t result = whd_init(&whd_drv, &whd_init_config, &resource_ops, &buffer_ops, &netif_ops);
+    if(result == CY_RSLT_SUCCESS)
+    {
+        result = init_sdio_bus(&whd_drv, &sdhc_obj);
+        if(result == CY_RSLT_SUCCESS)
+        {
+            result = whd_wifi_on(whd_drv, interface);
+        }
+    }
+    return result;
+}
+
+cy_rslt_t cybsp_wifi_init_secondary(whd_interface_t* interface, whd_mac_t* mac_address)
+{
+    return whd_add_secondary_interface(whd_drv, mac_address, interface);
+}
+
+cy_rslt_t cybsp_wifi_deinit(whd_interface_t interface)
+{
+    cy_rslt_t result = whd_wifi_off(interface);
+    if(result == CY_RSLT_SUCCESS)
+    {
+        result = whd_deinit(interface);
+        if(result == CY_RSLT_SUCCESS)
+        {
+            cyhal_gpio_free(CYBSP_WIFI_WL_REG_ON);
+        }
+    }
+    return result;
+}
+
+whd_driver_t cybsp_get_wifi_driver(void)
+{
+    return whd_drv;
+}
+
+#if defined(__cplusplus)
+}
+#endif
\ No newline at end of file
diff --git a/targets/TARGET_STM/TARGET_STM32H7/TARGET_STM32H747xI/TARGET_PORTENTA_H7/COMPONENT_WHD/port/cybsp_wifi.h b/targets/TARGET_STM/TARGET_STM32H7/TARGET_STM32H747xI/TARGET_PORTENTA_H7/COMPONENT_WHD/port/cybsp_wifi.h
new file mode 100644
index 0000000000..31bfc82566
--- /dev/null
+++ b/targets/TARGET_STM/TARGET_STM32H7/TARGET_STM32H747xI/TARGET_PORTENTA_H7/COMPONENT_WHD/port/cybsp_wifi.h
@@ -0,0 +1,109 @@
+/***************************************************************************//**
+* \file cybsp_wifi.h
+*
+* \brief
+* Basic abstraction layer for dealing with boards containing a Cypress MCU. This
+* API provides convenience methods for initializing and manipulating different
+* hardware found on the board.
+*
+********************************************************************************
+* \copyright
+* Copyright 2018-2019 Cypress Semiconductor Corporation
+* SPDX-License-Identifier: Apache-2.0
+*
+* Licensed under the Apache License, Version 2.0 (the "License");
+* you may not use this file except in compliance with the License.
+* You may obtain a copy of the License at
+*
+*     http://www.apache.org/licenses/LICENSE-2.0
+*
+* Unless required by applicable law or agreed to in writing, software
+* distributed under the License is distributed on an "AS IS" BASIS,
+* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+* See the License for the specific language governing permissions and
+* limitations under the License.
+*******************************************************************************/
+
+/**
+* \addtogroup group_bsp_wifi WiFi
+* \{
+* Basic abstraction layer for dealing with boards containing a Cypress MCU. This
+* API provides convenience methods for initializing and manipulating different
+* hardware found on the board.
+*
+* \defgroup group_bsp_wifi_macros Macros
+* \defgroup group_bsp_wifi_functions Functions
+*/
+#pragma once
+
+#include "cy_result.h"
+#include "whd_wifi_api.h"
+
+#if defined(__cplusplus)
+extern "C" {
+#endif
+
+/**
+* \addtogroup group_bsp_wifi_macros
+* \{
+*/
+
+/** Initialization of the WiFi driver failed. */
+#define CYBSP_RSLT_WIFI_INIT_FAILED (CY_RSLT_CREATE(CY_RSLT_TYPE_ERROR, CY_RSLT_MODULE_ABSTRACTION_BSP, 4))
+
+/** SDIO enumeration failed. */
+#define CYBSP_RSLT_WIFI_SDIO_ENUM_TIMEOUT (CY_RSLT_CREATE(CY_RSLT_TYPE_ERROR, CY_RSLT_MODULE_ABSTRACTION_BSP, 5))
+
+/** \} group_bsp_board_macros */
+
+/**
+* \addtogroup group_bsp_wifi_functions
+* \{
+*/
+
+/** Initializes the primary interface for the WiFi driver on the board. This function
+ * does the following
+ * 1) Initializes the WiFi driver.
+ * 2) Turns on the WiFi chip.
+ *
+ * @note This function cannot be called multiple times. The user needs to first de-initialize
+ * before calling this function again.
+ * 
+ * @param[out] interface Interface to be initialized 
+ * @return CY_RSLT_SUCCESS for successful initialization or error if initialization failed.
+ */
+cy_rslt_t cybsp_wifi_init_primary(whd_interface_t* interface);
+
+/** This function initializes and adds a secondary interface to the WiFi driver.
+ *  @note This function does not initialize the WiFi driver or turn on the WiFi chip.
+ * That is required to be done by the primary interface
+ * 
+ * @param[out] interface Interface to be initialized
+ * @param[in] mac_address Mac address for secondary interface
+ * @return CY_RSLT_SUCCESS for successful initialization or error if initialization failed.
+ */
+cy_rslt_t cybsp_wifi_init_secondary(whd_interface_t* interface, whd_mac_t* mac_address);
+
+/** De-initializes all WiFi interfaces and the WiFi driver. This function does the following
+ * 1) Deinitializes all WiFi interfaces and WiFi driver.
+ * 2) Turns off the WiFi chip.
+ *
+ * @param[in] interface Interface to be de-initialized.
+ * @return CY_RSLT_SUCCESS for successful de-initialization or error if de-initialization failed.
+ */
+cy_rslt_t cybsp_wifi_deinit(whd_interface_t interface);
+
+/** Gets the wifi driver instance initialized by the driver. This should only be called
+ * after the interface is initialized by cybsp_wifi_init_primary().
+ *
+ * @return Wifi driver instance pointer.
+ */
+whd_driver_t cybsp_get_wifi_driver(void);
+
+/** \} group_bsp_wifi_functions */
+
+#ifdef __cplusplus
+}
+#endif /* __cplusplus */
+
+/** \} group_bsp_wifi */
diff --git a/targets/TARGET_STM/TARGET_STM32H7/TARGET_STM32H747xI/TARGET_PORTENTA_H7/COMPONENT_WHD/whd_config.h b/targets/TARGET_STM/TARGET_STM32H7/TARGET_STM32H747xI/TARGET_PORTENTA_H7/COMPONENT_WHD/whd_config.h
new file mode 100644
index 0000000000..e56faf6f68
--- /dev/null
+++ b/targets/TARGET_STM/TARGET_STM32H7/TARGET_STM32H747xI/TARGET_PORTENTA_H7/COMPONENT_WHD/whd_config.h
@@ -0,0 +1,66 @@
+/*
+ * Copyright 2020 Arduino SA
+ * SPDX-License-Identifier: Apache-2.0
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+/** @file
+ *  Provides configuration for WHD driver on Arduino Portenta H7
+ */
+
+#ifndef __WHD_CONFIG__
+#define __WHD_CONFIG__
+
+#include "cyhal_gpio.h"
+#include "whd_types.h"
+#include "stm32h7xx_hal.h"
+#include <stdint.h>
+
+#define WHD_COUNTRY     WHD_COUNTRY_AUSTRALIA
+
+/* Internal thread config    */
+#define WHD_THREAD_STACK_SIZE   5120
+#define WHD_THREAD_PRIORITY     osPriorityHigh
+
+/* please define your configuration , either SDIO or SPI */
+#define CY_WHD_CONFIG_USE_SDIO
+//#define CY_WHD_CONFIG_USE_SPI
+
+/* Set Timeout for your platform */
+#define WLAN_POWER_UP_DELAY_MS  		250
+#define SDIO_ENUMERATION_TIMEOUT_MS     500
+
+#define USES_RESOURCE_GENERIC_FILESYSTEM
+
+#define BSP_LED1   	{GPIOK,{.Pin= GPIO_PIN_5 , .Mode = GPIO_MODE_OUTPUT_PP , .Pull = GPIO_NOPULL , .Speed= GPIO_SPEED_FREQ_LOW}}
+#define BSP_LED2		{GPIOK,{.Pin= GPIO_PIN_6 , .Mode = GPIO_MODE_OUTPUT_PP , .Pull = GPIO_NOPULL , .Speed= GPIO_SPEED_FREQ_LOW}}
+#define BSP_LED3		{GPIOK,{.Pin= GPIO_PIN_7 , .Mode = GPIO_MODE_OUTPUT_PP , .Pull = GPIO_NOPULL , .Speed= GPIO_SPEED_FREQ_LOW}}
+
+/* power pin */
+#define WIFI_WL_REG_ON  	{GPIOJ,{.Pin= GPIO_PIN_1, .Mode = GPIO_MODE_OUTPUT_PP , .Pull = GPIO_NOPULL , .Speed= GPIO_SPEED_FREQ_LOW}}
+//#define WIFI_32K_CLK    	{GPIOA,{.Pin= GPIO_PIN_8, .Mode = GPIO_MODE_AF_PP , .Pull = GPIO_NOPULL , .Speed= GPIO_SPEED_FREQ_LOW , .Alternate = GPIO_AF0_MCO}}
+
+#define WIFI_SDIO_CMD		{GPIOD,{.Pin= GPIO_PIN_2 , .Mode = GPIO_MODE_AF_PP , .Pull = GPIO_NOPULL , .Speed= GPIO_SPEED_FREQ_VERY_HIGH, .Alternate = GPIO_AF12_SDIO1}}
+#define WIFI_SDIO_CLK  		{GPIOC,{.Pin= GPIO_PIN_12, .Mode = GPIO_MODE_AF_PP , .Pull = GPIO_NOPULL , .Speed= GPIO_SPEED_FREQ_VERY_HIGH, .Alternate = GPIO_AF12_SDIO1}}
+#define WIFI_SDIO_D0		{GPIOC,{.Pin= GPIO_PIN_8 , .Mode = GPIO_MODE_AF_PP , .Pull = GPIO_NOPULL , .Speed= GPIO_SPEED_FREQ_VERY_HIGH, .Alternate = GPIO_AF12_SDIO1}}
+#define WIFI_SDIO_D1		{GPIOC,{.Pin= GPIO_PIN_9 , .Mode = GPIO_MODE_AF_PP , .Pull = GPIO_NOPULL , .Speed= GPIO_SPEED_FREQ_VERY_HIGH, .Alternate = GPIO_AF12_SDIO1}}
+#define WIFI_SDIO_D2		{GPIOC,{.Pin= GPIO_PIN_10, .Mode = GPIO_MODE_AF_PP , .Pull = GPIO_NOPULL , .Speed= GPIO_SPEED_FREQ_VERY_HIGH, .Alternate = GPIO_AF12_SDIO1}}
+#define WIFI_SDIO_D3 		{GPIOC,{.Pin= GPIO_PIN_11, .Mode = GPIO_MODE_AF_PP , .Pull = GPIO_NOPULL , .Speed= GPIO_SPEED_FREQ_VERY_HIGH, .Alternate = GPIO_AF12_SDIO1}}
+#define WIFI_SDIO_OOB_IRQ 	{GPIOJ,{.Pin= GPIO_PIN_5,  .Mode = GPIO_MODE_IT_FALLING , .Pull = GPIO_NOPULL , .Speed= GPIO_SPEED_FREQ_VERY_HIGH}}
+
+#ifndef CYHAL_NC_PIN_VALUE
+#define CYHAL_NC_PIN_VALUE ( (cyhal_gpio_t)0xFFFFFFFF )
+#endif
+
+#endif
-- 
2.30.1

